var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},e={},n={},r=t.parcelRequire5b70;null==r&&((r=function(t){if(t in e)return e[t].exports;if(t in n){var r=n[t];delete n[t];var a={id:t,exports:{}};return e[t]=a,r.call(a.exports,a,a.exports),a.exports}var i=new Error("Cannot find module '"+t+"'");throw i.code="MODULE_NOT_FOUND",i}).register=function(t,e){n[t]=e},t.parcelRequire5b70=r);var a=r("ilwiq"),i=r("kp7Te"),o=r("891vQ"),s=r("7lx9d");a=r("ilwiq");const l=new a.Vector3,c=new a.Vector3;class d extends a.ShaderMaterial{constructor(t){super({uniforms:a.UniformsUtils.merge([a.UniformsLib.fog,{diffuse:{value:new a.Color},opacity:{value:1}}]),vertexShader:"\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t"}),Object.defineProperties(this,{opacity:{get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},color:{get:function(){return this.uniforms.diffuse.value}}}),this.setValues(t),this.isLDrawConditionalLineMaterial=!0}}class u extends a.LineSegments{constructor(t,e){super(t,e),this.isConditionalLine=!0}}const h=new a.Ray;function m(t){return"Part"===t||"Unofficial_Part"===t}class p{constructor(t,e){this.line=t,this.lineLength=t.length,this.currentCharIndex=0,this.currentChar=" ",this.lineNumber=e}seekNonSpace(){for(;this.currentCharIndex<this.lineLength;){if(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar)return;this.currentCharIndex++}}getToken(){const t=this.currentCharIndex++;for(;this.currentCharIndex<this.lineLength&&(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar);)this.currentCharIndex++;const e=this.currentCharIndex;return this.seekNonSpace(),this.line.substring(t,e)}getVector(){return new a.Vector3(parseFloat(this.getToken()),parseFloat(this.getToken()),parseFloat(this.getToken()))}getRemainingString(){return this.line.substring(this.currentCharIndex,this.lineLength)}isAtTheEnd(){return this.currentCharIndex>=this.lineLength}setToEnd(){this.currentCharIndex=this.lineLength}getLineNumberString(){return this.lineNumber>=0?" at line "+this.lineNumber:""}}class g{constructor(t){this.loader=t,this._cache={}}cloneResult(t){const e={};return e.faces=t.faces.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone())),normals:t.normals.map((()=>null)),faceNormal:null}))),e.conditionalSegments=t.conditionalSegments.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone())),controlPoints:t.controlPoints.map((t=>t.clone()))}))),e.lineSegments=t.lineSegments.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone()))}))),e.type=t.type,e.category=t.category,e.keywords=t.keywords,e.subobjects=t.subobjects,e.totalFaces=t.totalFaces,e.startingConstructionStep=t.startingConstructionStep,e.materials=t.materials,e.group=null,e}async fetchData(t){let e=!1,n=0;for(;6!==n;){let r=t;switch(n){case 0:n+=1;break;case 1:r="parts/"+r,n+=1;break;case 2:r="p/"+r,n+=1;break;case 3:r="models/"+r,n+=1;break;case 4:r=t.substring(0,t.lastIndexOf("/")+1)+r,n+=1;break;case 5:e?n=6:(r=t=t.toLowerCase(),e=!0,n=0)}const i=this.loader,o=new a.FileLoader(i.manager);o.setPath(i.partsLibraryPath),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials);try{return await o.loadAsync(r)}catch{continue}}throw new Error('LDrawLoader: Subobject "'+t+'" could not be loaded.')}parse(t,e=null){const n=this.loader,r=[],i=[],o=[],s=[],l={},c=t=>l[t]||null;let d="Model",u=null,h=null,m=0;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n"));const g=t.split("\n"),f=g.length;let b=!1,v=null,y=null,w=!1,M=!0,x=!1,C=!0,S=!1;for(let t=0;t<f;t++){const e=g[t];if(0===e.length)continue;if(b){e.startsWith("0 FILE ")?(this.setData(v,y),v=e.substring(7),y=""):y+=e+"\n";continue}const f=new p(e,t+1);if(f.seekNonSpace(),f.isAtTheEnd())continue;const L=f.getToken();let T,E,_,A,D,k,R,F,P,I,N;switch(L){case"0":const e=f.getToken();if(e)switch(e){case"!LDRAW_ORG":d=f.getToken();break;case"!COLOUR":T=n.parseColorMetaDirective(f),T?l[T.userData.code]=T:console.warn("LDrawLoader: Error parsing material"+f.getLineNumberString());break;case"!CATEGORY":u=f.getToken();break;case"!KEYWORDS":const e=f.getRemainingString().split(",");e.length>0&&(h||(h=[]),e.forEach((function(t){h.push(t.trim())})));break;case"FILE":t>0&&(b=!0,v=f.getRemainingString(),y="",w=!1,M=!0);break;case"BFC":for(;!f.isAtTheEnd();){const t=f.getToken();switch(t){case"CERTIFY":case"NOCERTIFY":w="CERTIFY"===t,M=!0;break;case"CW":case"CCW":M="CCW"===t;break;case"INVERTNEXT":x=!0;break;case"CLIP":case"NOCLIP":C="CLIP"===t;break;default:console.warn('THREE.LDrawLoader: BFC directive "'+t+'" is unknown.')}}break;case"STEP":S=!0}break;case"1":E=f.getToken(),T=c(E);const p=parseFloat(f.getToken()),g=parseFloat(f.getToken()),O=parseFloat(f.getToken()),B=parseFloat(f.getToken()),V=parseFloat(f.getToken()),G=parseFloat(f.getToken()),z=parseFloat(f.getToken()),j=parseFloat(f.getToken()),U=parseFloat(f.getToken()),W=parseFloat(f.getToken()),H=parseFloat(f.getToken()),q=parseFloat(f.getToken()),Y=(new a.Matrix4).set(B,V,G,p,z,j,U,g,W,H,q,O,0,0,0,1);let $=f.getRemainingString().trim().replace(/\\/g,"/");n.fileMap[$]?$=n.fileMap[$]:$.startsWith("s/")?$="parts/"+$:$.startsWith("48/")&&($="p/"+$),s.push({material:T,colorCode:E,matrix:Y,fileName:$,inverted:x,startingConstructionStep:S}),x=!1;break;case"2":E=f.getToken(),T=c(E),k=f.getVector(),R=f.getVector(),_={material:T,colorCode:E,vertices:[k,R]},i.push(_);break;case"5":E=f.getToken(),T=c(E),k=f.getVector(),R=f.getVector(),I=f.getVector(),N=f.getVector(),_={material:T,colorCode:E,vertices:[k,R],controlPoints:[I,N]},o.push(_);break;case"3":E=f.getToken(),T=c(E),A=M,D=!w||!C,!0===A?(k=f.getVector(),R=f.getVector(),F=f.getVector()):(F=f.getVector(),R=f.getVector(),k=f.getVector()),r.push({material:T,colorCode:E,faceNormal:null,vertices:[k,R,F],normals:[null,null,null]}),m++,!0===D&&(r.push({material:T,colorCode:E,faceNormal:null,vertices:[F,R,k],normals:[null,null,null]}),m++);break;case"4":E=f.getToken(),T=c(E),A=M,D=!w||!C,!0===A?(k=f.getVector(),R=f.getVector(),F=f.getVector(),P=f.getVector()):(P=f.getVector(),F=f.getVector(),R=f.getVector(),k=f.getVector()),r.push({material:T,colorCode:E,faceNormal:null,vertices:[k,R,F,P],normals:[null,null,null,null]}),m+=2,!0===D&&(r.push({material:T,colorCode:E,faceNormal:null,vertices:[P,F,R,k],normals:[null,null,null,null]}),m+=2);break;default:throw new Error('LDrawLoader: Unknown line type "'+L+'"'+f.getLineNumberString()+".")}}return b&&this.setData(v,y),{faces:r,conditionalSegments:o,lineSegments:i,type:d,category:u,keywords:h,subobjects:s,totalFaces:m,startingConstructionStep:S,materials:l,fileName:e,group:null}}getData(t,e=!0){const n=t.toLowerCase(),r=this._cache[n];return null===r||r instanceof Promise?null:e?this.cloneResult(r):r}async ensureDataLoaded(t){const e=t.toLowerCase();e in this._cache||(this._cache[e]=this.fetchData(t).then((n=>{const r=this.parse(n,t);return this._cache[e]=r,r}))),await this._cache[e]}setData(t,e){const n=t.toLowerCase();this._cache[n]=this.parse(e,t)}}function f(t,e,n,r){return(!r&&"16"===t||r&&"24"===t)&&(t=e),n[t]||null}class b{constructor(t){this.loader=t,this.parseCache=new g(t),this._cache={}}async processIntoMesh(t){const e=this.loader,n=this.parseCache,r=new Set,i=async(t,o=null)=>{const s=t.subobjects,l=[];for(let t=0,e=s.length;t<e;t++){const e=s[t],r=n.ensureDataLoaded(e.fileName).then((()=>{const t=n.getData(e.fileName,!1);return r=t.type,/primitive/i.test(r)||"Subpart"===r?i(n.getData(e.fileName),e):this.loadModel(e.fileName).catch((t=>(console.warn(t),null)));var r}));l.push(r)}const c=new a.Group;c.userData.category=t.category,c.userData.keywords=t.keywords,t.group=c;const d=await Promise.all(l);for(let n=0,a=d.length;n<a;n++){const a=t.subobjects[n],i=d[n];if(null===i)continue;if(i.isGroup){const n=i;a.matrix.decompose(n.position,n.quaternion,n.scale),n.userData.startingConstructionStep=a.startingConstructionStep,n.name=a.fileName,e.applyMaterialsToMesh(n,a.colorCode,t.materials),c.add(n);continue}i.group.children.length&&c.add(i.group);const o=t.lineSegments,s=t.conditionalSegments,l=t.faces,u=i.lineSegments,h=i.conditionalSegments,m=i.faces,p=a.matrix,g=a.inverted,b=p.determinant()<0,v=a.colorCode,y="16"===v?"24":v;for(let e=0,n=u.length;e<n;e++){const n=u[e],r=n.vertices;r[0].applyMatrix4(p),r[1].applyMatrix4(p),n.colorCode="24"===n.colorCode?y:n.colorCode,n.material=n.material||f(n.colorCode,n.colorCode,t.materials,!0),o.push(n)}for(let e=0,n=h.length;e<n;e++){const n=h[e],r=n.vertices,a=n.controlPoints;r[0].applyMatrix4(p),r[1].applyMatrix4(p),a[0].applyMatrix4(p),a[1].applyMatrix4(p),n.colorCode="24"===n.colorCode?y:n.colorCode,n.material=n.material||f(n.colorCode,n.colorCode,t.materials,!0),s.push(n)}for(let e=0,n=m.length;e<n;e++){const n=m[e],a=n.vertices;for(let t=0,e=a.length;t<e;t++)a[t].applyMatrix4(p);n.colorCode="16"===n.colorCode?v:n.colorCode,n.material=n.material||f(n.colorCode,v,t.materials,!1),r.add(n.colorCode),b!==g&&a.reverse(),l.push(n)}t.totalFaces+=i.totalFaces}return o&&e.applyMaterialsToMesh(c,o.colorCode,t.materials),t};for(let e=0,n=t.faces;e<n;e++)r.add(t.faces[e].colorCode);if(await i(t),e.smoothNormals){const e=r.size>1;!function(t){for(let e=0,n=t.length;e<n;e++){const n=t[e],r=n.vertices,i=r[0],o=r[1],s=r[2];l.subVectors(o,i),c.subVectors(s,o),n.faceNormal=(new a.Vector3).crossVectors(l,c).normalize()}}(t.faces),function(t,e,n=!1){const r=100*(1+1e-10);function i(t){return`${~~(t.x*r)},${~~(t.y*r)},${~~(t.z*r)}`}function o(t,e){return`${i(t)}_${i(e)}`}function s(t,e,n){n.direction.subVectors(e,t).normalize();const r=t.dot(n.direction);return n.origin.copy(t).addScaledVector(n.direction,-r),n}function l(t){return o(t.origin,t.direction)}const c=new Set,d=new Map,u={},m=[];for(let t=0,r=e.length;t<r;t++){const r=e[t].vertices,i=r[0],u=r[1];if(c.add(o(i,u)),c.add(o(u,i)),n){const t=s(i,u,new a.Ray),e=l(t);if(!d.has(e)){s(u,i,t);const n=l(t),r={ray:t,distances:[]};d.set(e,r),d.set(n,r)}const n=d.get(e);let r=n.ray.direction.dot(i),o=n.ray.direction.dot(u);r>o&&([r,o]=[o,r]),n.distances.push(r,o)}}for(let e=0,r=t.length;e<r;e++){const r=t[e],a=r.vertices,i=a.length;for(let t=0;t<i;t++){const e=t,m=(t+1)%i,p=a[e],g=a[m],f=o(p,g);if(c.has(f))continue;if(n){s(p,g,h);const t=l(h);if(d.has(t)){const e=d.get(t),{ray:n,distances:r}=e;let a=n.direction.dot(p),i=n.direction.dot(g);a>i&&([a,i]=[i,a]);let o=!1;for(let t=0,e=r.length;t<e;t+=2)if(a>=r[t]&&i<=r[t+1]){o=!0;break}if(o)continue}}const b={index:e,tri:r};u[f]=b}}for(;;){let t=null;for(const e in u){t=u[e];break}if(null===t)break;const e=[t];for(;e.length>0;){const t=e.pop().tri,n=t.vertices,r=t.normals,i=t.faceNormal,s=n.length;for(let l=0;l<s;l++){const c=l,d=(l+1)%s,h=n[c],p=n[d];delete u[o(h,p)];const g=o(p,h),f=u[g];if(f){const n=f.tri,o=f.index,s=n.normals,l=s.length,h=n.faceNormal;if(Math.abs(n.faceNormal.dot(t.faceNormal))<.25)continue;g in u&&(e.push(f),delete u[g]);const p=(o+1)%l;r[c]&&s[p]&&r[c]!==s[p]&&(s[p].norm.add(r[c].norm),r[c].norm=s[p].norm);let b=r[c]||s[p];null===b&&(b={norm:new a.Vector3},m.push(b.norm)),null===r[c]&&(r[c]=b,b.norm.add(i)),null===s[p]&&(s[p]=b,b.norm.add(h)),r[d]&&s[o]&&r[d]!==s[o]&&(s[o].norm.add(r[d].norm),r[d].norm=s[o].norm);let v=r[d]||s[o];null===v&&(v={norm:new a.Vector3},m.push(v.norm)),null===r[d]&&(r[d]=v,v.norm.add(i)),null===s[o]&&(s[o]=v,v.norm.add(h))}}}}for(let t=0,e=m.length;t<e;t++)m[t].normalize()}(t.faces,t.lineSegments,e)}const o=t.group;return t.faces.length>0&&o.add(y(t.faces,3,!1,t.totalFaces)),t.lineSegments.length>0&&o.add(y(t.lineSegments,2)),t.conditionalSegments.length>0&&o.add(y(t.conditionalSegments,2,!0)),o}hasCachedModel(t){return null!==t&&t.toLowerCase()in this._cache}async getCachedModel(t){if(null!==t&&this.hasCachedModel(t)){const e=t.toLowerCase();return(await this._cache[e]).clone()}return null}async loadModel(t){const e=this.parseCache,n=t.toLowerCase();if(this.hasCachedModel(t))return this.getCachedModel(t);{await e.ensureDataLoaded(t);const r=e.getData(t),a=this.processIntoMesh(r);if(this.hasCachedModel(t))return this.getCachedModel(t);m(r.type)&&(this._cache[n]=a);return(await a).clone()}}async parseModel(t){const e=this.parseCache.parse(t);return m(e.type)&&this.hasCachedModel(e.fileName)?this.getCachedModel(e.fileName):this.processIntoMesh(e)}}function v(t,e){return t.colorCode===e.colorCode?0:t.colorCode<e.colorCode?-1:1}function y(t,e,n=!1,r=null){t.sort(v),null===r&&(r=t.length);const i=new Float32Array(e*r*3),o=3===e?new Float32Array(e*r*3):null,s=[],d=new Array(6),h=new a.BufferGeometry;let m=null,p=0,g=0,f=0;for(let r=0,u=t.length;r<u;r++){const u=t[r];let b=u.vertices;4===b.length&&(d[0]=b[0],d[1]=b[1],d[2]=b[2],d[3]=b[0],d[4]=b[2],d[5]=b[3],b=d);for(let t=0,e=b.length;t<e;t++){const e=b[t],n=f+3*t;i[n+0]=e.x,i[n+1]=e.y,i[n+2]=e.z}if(3===e){if(!u.faceNormal){const t=b[0],e=b[1],n=b[2];l.subVectors(e,t),c.subVectors(n,e),u.faceNormal=(new a.Vector3).crossVectors(l,c).normalize()}let t=u.normals;4===t.length&&(d[0]=t[0],d[1]=t[1],d[2]=t[2],d[3]=t[0],d[4]=t[2],d[5]=t[3],t=d);for(let e=0,n=t.length;e<n;e++){let n=u.faceNormal;t[e]&&(n=t[e].norm);const r=f+3*e;o[r+0]=n.x,o[r+1]=n.y,o[r+2]=n.z}}if(m!==u.colorCode){null!==m&&h.addGroup(p,g,s.length-1);const t=u.material;null!==t?3===e?s.push(t):2===e&&(null!==t?n?s.push(t.userData.edgeMaterial.userData.conditionalEdgeMaterial):s.push(t.userData.edgeMaterial):s.push(null)):s.push(u.colorCode),m=u.colorCode,p=f/3,g=b.length}else g+=b.length;f+=3*b.length}g>0&&h.addGroup(p,1/0,s.length-1),h.setAttribute("position",new a.BufferAttribute(i,3)),null!==o&&h.setAttribute("normal",new a.BufferAttribute(o,3));let b=null;if(2===e?b=n?new u(h,1===s.length?s[0]:s):new a.LineSegments(h,1===s.length?s[0]:s):3===e&&(b=new a.Mesh(h,1===s.length?s[0]:s)),n){b.isConditionalLine=!0;const e=new Float32Array(6*t.length),n=new Float32Array(6*t.length),r=new Float32Array(6*t.length);for(let a=0,i=t.length;a<i;a++){const i=t[a],o=i.vertices,s=i.controlPoints,l=s[0],c=s[1],d=o[0],u=o[1],h=6*a;e[h+0]=l.x,e[h+1]=l.y,e[h+2]=l.z,e[h+3]=l.x,e[h+4]=l.y,e[h+5]=l.z,n[h+0]=c.x,n[h+1]=c.y,n[h+2]=c.z,n[h+3]=c.x,n[h+4]=c.y,n[h+5]=c.z,r[h+0]=u.x-d.x,r[h+1]=u.y-d.y,r[h+2]=u.z-d.z,r[h+3]=u.x-d.x,r[h+4]=u.y-d.y,r[h+5]=u.z-d.z}h.setAttribute("control0",new a.BufferAttribute(e,3,!1)),h.setAttribute("control1",new a.BufferAttribute(n,3,!1)),h.setAttribute("direction",new a.BufferAttribute(r,3,!1))}return b}class w extends a.Loader{constructor(t){super(t),this.materials=[],this.materialLibrary={},this.partsCache=new b(this),this.fileMap={},this.setMaterials([]),this.smoothNormals=!0,this.partsLibraryPath=""}setPartsLibraryPath(t){return this.partsLibraryPath=t,this}async preloadMaterials(t){const e=new a.FileLoader(this.manager);e.setPath(this.path),e.setRequestHeader(this.requestHeader),e.setWithCredentials(this.withCredentials);const n=/^0 !COLOUR/,r=(await e.loadAsync(t)).split(/[\n\r]/g),i=[];for(let t=0,e=r.length;t<e;t++){const e=r[t];if(n.test(e)){const t=e.replace(n,""),r=this.parseColorMetaDirective(new p(t));i.push(r)}}this.setMaterials(i)}load(t,e,n,r){const i=new a.FileLoader(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,(t=>{this.partsCache.parseModel(t,this.materialLibrary).then((t=>{this.applyMaterialsToMesh(t,"16",this.materialLibrary,!0),this.computeConstructionSteps(t),e(t)})).catch(r)}),n,r)}parse(t,e){this.partsCache.parseModel(t,this.materialLibrary).then((t=>{this.computeConstructionSteps(t),e(t)}))}setMaterials(t){this.materialLibrary={},this.materials=[];for(let e=0,n=t.length;e<n;e++)this.addMaterial(t[e]);return this.addMaterial(this.parseColorMetaDirective(new p("Main_Colour CODE 16 VALUE #FF8080 EDGE #333333"))),this.addMaterial(this.parseColorMetaDirective(new p("Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333"))),this}setFileMap(t){return this.fileMap=t,this}addMaterial(t){const e=this.materialLibrary;return e[t.userData.code]||(this.materials.push(t),e[t.userData.code]=t),this}getMaterial(t){if(t.startsWith("0x2")){const e=t.substring(3);return this.parseColorMetaDirective(new p("Direct_Color_"+e+" CODE -1 VALUE #"+e+" EDGE #"+e))}return this.materialLibrary[t]||null}applyMaterialsToMesh(t,e,n,r=!1){const a=this,i="16"===e;function o(t,o){if(i&&!(o in n)&&!r)return o;const s=t.isLineSegments||t.isConditionalLine;(!s&&"16"===o||s&&"24"===o)&&(o=e);let l=null;if(o in n)l=n[o];else{if(!r)return o;if(l=a.getMaterial(o),null===l)throw new Error(`LDrawLoader: Material properties for code ${o} not available.`)}return t.isLineSegments&&(l=l.userData.edgeMaterial,t.isConditionalLine&&(l=l.userData.conditionalEdgeMaterial)),l}t.traverse((t=>{if(t.isMesh||t.isLineSegments)if(Array.isArray(t.material))for(let e=0,n=t.material.length;e<n;e++)t.material[e].isMaterial||(t.material[e]=o(t,t.material[e]));else t.material.isMaterial||(t.material=o(t,t.material))}))}getMainMaterial(){return this.getMaterial("16")}getMainEdgeMaterial(){const t=this.getMainMaterial();return t&&t.userData?t.userData.edgeMaterial:null}parseColorMetaDirective(t){let e=null,n=16711935,r=16711935,i=1,o=!1,s=0,l=0,c=null;const u=t.getToken();if(!u)throw new Error('LDrawLoader: Material name was expected after "!COLOUR tag'+t.getLineNumberString()+".");let h=null;for(;h=t.getToken(),h;)switch(h.toUpperCase()){case"CODE":e=t.getToken();break;case"VALUE":if(n=t.getToken(),n.startsWith("0x"))n="#"+n.substring(2);else if(!n.startsWith("#"))throw new Error("LDrawLoader: Invalid color while parsing material"+t.getLineNumberString()+".");break;case"EDGE":if(r=t.getToken(),r.startsWith("0x"))r="#"+r.substring(2);else if(!r.startsWith("#")){if(c=this.getMaterial(r),!c)throw new Error("LDrawLoader: Invalid edge color while parsing material"+t.getLineNumberString()+".");c=c.userData.edgeMaterial}break;case"ALPHA":if(i=parseInt(t.getToken()),isNaN(i))throw new Error("LDrawLoader: Invalid alpha value in material definition"+t.getLineNumberString()+".");i=Math.max(0,Math.min(1,i/255)),i<1&&(o=!0);break;case"LUMINANCE":if(s=parseInt(t.getToken()),isNaN(s))throw new Error("LDrawLoader: Invalid luminance value in material definition"+p.getLineNumberString()+".");s=Math.max(0,Math.min(1,s/255));break;case"CHROME":l=1;break;case"PEARLESCENT":l=2;break;case"RUBBER":l=3;break;case"MATTE_METALLIC":l=4;break;case"METAL":l=5;break;case"MATERIAL":t.setToEnd();break;default:throw new Error('LDrawLoader: Unknown token "'+h+'" while parsing material'+t.getLineNumberString()+".")}let m=null;switch(l){case 0:m=new a.MeshStandardMaterial({color:n,roughness:.3,metalness:0});break;case 2:m=new a.MeshStandardMaterial({color:n,roughness:.3,metalness:.25});break;case 1:m=new a.MeshStandardMaterial({color:n,roughness:0,metalness:1});break;case 3:m=new a.MeshStandardMaterial({color:n,roughness:.9,metalness:0});break;case 4:m=new a.MeshStandardMaterial({color:n,roughness:.8,metalness:.4});break;case 5:m=new a.MeshStandardMaterial({color:n,roughness:.2,metalness:.85})}return m.transparent=o,m.premultipliedAlpha=!0,m.opacity=i,m.depthWrite=!o,m.color.convertSRGBToLinear(),m.polygonOffset=!0,m.polygonOffsetFactor=1,0!==s&&m.emissive.set(m.color).multiplyScalar(s),c||(c=new a.LineBasicMaterial({color:r,transparent:o,opacity:i,depthWrite:!o}),c.userData.code=e,c.name=u+" - Edge",c.color.convertSRGBToLinear(),c.userData.conditionalEdgeMaterial=new d({fog:!0,transparent:o,depthWrite:!o,color:r,opacity:i}),c.userData.conditionalEdgeMaterial.color.convertSRGBToLinear()),m.userData.code=e,m.name=u,m.userData.edgeMaterial=c,this.addMaterial(m),m}computeConstructionSteps(t){let e=0;t.traverse((t=>{t.isGroup&&(t.userData.startingConstructionStep&&e++,t.userData.constructionStep=e)})),t.userData.numConstructionSteps=e+1}}a=r("ilwiq");var M=r("7ePFa");var x=r("jiuw3"),C=(a=r("ilwiq"),r("5Rd1x")),S=r("RPVlj"),L=r("8Zfx2"),T=r("a8VBx"),E=r("hWds8"),_=r("jM3IF"),A=(a=r("ilwiq"),L=r("8Zfx2"),r("5Wq6T")),D=r("dJ2FF"),k=r("12pjC");class R extends a.ShaderMaterial{constructor(t){super({defines:{BOUNCES:3,MATERIAL_LENGTH:0,USE_ENVMAP:1,GRADIENT_BG:0,DISPLAY_FLOOR:1},uniforms:{bvh:{value:new L.MeshBVHUniformStruct},normalAttribute:{value:new L.FloatVertexAttributeTexture},tangentAttribute:{value:new L.FloatVertexAttributeTexture},uvAttribute:{value:new L.FloatVertexAttributeTexture},materialIndexAttribute:{value:new L.UIntVertexAttributeTexture},materials:{value:new D.MaterialStructArrayUniform},textures:{value:(new k.RenderTarget2DArray).texture},cameraWorldMatrix:{value:new a.Matrix4},invProjectionMatrix:{value:new a.Matrix4},environmentBlur:{value:.2},environmentIntensity:{value:2},environmentMap:{value:null},seed:{value:0},opacity:{value:1},gradientTop:{value:new a.Color(12572927)},gradientBottom:{value:new a.Color(16777215)},bgGradientTop:{value:new a.Color(1118481)},bgGradientBottom:{value:new a.Color(0)},floorHeight:{value:0},floorColor:{value:new a.Color(526344)}},vertexShader:"\n\n                varying vec2 vUv;\n                void main() {\n\n                    vec4 mvPosition = vec4( position, 1.0 );\n                    mvPosition = modelViewMatrix * mvPosition;\n                    gl_Position = projectionMatrix * mvPosition;\n\n                    vUv = uv;\n\n                }\n\n            ",fragmentShader:`\n                #define RAY_OFFSET 1e-5\n\t\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n                precision highp isampler2D;\n                precision highp usampler2D;\n                precision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n                #include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n                ${L.shaderStructs}\n                ${L.shaderIntersectFunction}\n\t\t\t\t${A.shaderMaterialStructs}\n\t\t\t\t${A.pathTracingHelpers}\n\n\t\t\t\t#if USE_ENVMAP\n\n\t\t\t\tuniform float environmentBlur;\n                uniform sampler2D environmentMap;\n\n\t\t\t\t#else\n\n                uniform vec3 gradientTop;\n                uniform vec3 gradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if GRADIENT_BG\n\n\t\t\t\tuniform vec3 bgGradientTop;\n                uniform vec3 bgGradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if DISPLAY_FLOOR\n\n\t\t\t\tuniform vec3 floorColor;\n\t\t\t\tuniform float floorHeight;\n\n\t\t\t\t#endif\n\n                uniform mat4 cameraWorldMatrix;\n                uniform mat4 invProjectionMatrix;\n                uniform sampler2D normalAttribute;\n                uniform sampler2D tangentAttribute;\n                uniform sampler2D uvAttribute;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n                uniform BVH bvh;\n                uniform float environmentIntensity;\n                uniform int seed;\n                uniform float opacity;\n\t\t\t\tuniform Material materials[ MATERIAL_LENGTH ];\n\t\t\t\tuniform sampler2DArray textures;\n                varying vec2 vUv;\n\n                void main() {\n\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\n                    // get [-1, 1] normalized device coordinates\n                    vec2 ndc = 2.0 * vUv - vec2( 1.0 );\n                    vec3 rayOrigin, rayDirection;\n                    ndcToCameraRay( ndc, cameraWorldMatrix, invProjectionMatrix, rayOrigin, rayDirection );\n\n                    // Lambertian render\n                    gl_FragColor = vec4( 0.0 );\n\n                    vec3 throughputColor = vec3( 1.0 );\n\n                    // hit results\n                    uvec4 faceIndices = uvec4( 0u );\n                    vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n                    vec3 barycoord = vec3( 0.0 );\n                    float side = 1.0;\n                    float dist = 0.0;\n\t\t\t\t\tint i;\n                    for ( i = 0; i < BOUNCES; i ++ ) {\n\n                        if ( ! bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist ) ) {\n\n\t\t\t\t\t\t\t#if DISPLAY_FLOOR\n\n\t\t\t\t\t\t\t// display a radial gradient floor\n\t\t\t\t\t\t\tfloat distToFloor = ( floorHeight - rayOrigin.y ) / rayDirection.y;\n\t\t\t\t\t\t\tvec3 floorNormal = vec3( 0.0, 1.0, 0.0 );\n\t\t\t\t\t\t\tvec3 floorHitPoint = rayOrigin + rayDirection * distToFloor + floorNormal * RAY_OFFSET;\n\t\t\t\t\t\t\tfloat centerDist = length( floorHitPoint.xz );\n\t\t\t\t\t\t\tfloat alpha = pow( saturate( 1.25 - centerDist ), 2.0 );\n\t\t\t\t\t\t\tif ( distToFloor > dist && dot( floorNormal, rayDirection ) < 0.0 && alpha > rand() ) {\n\n\t\t\t\t\t\t\t\trayOrigin = floorHitPoint;\n\t\t\t\t\t\t\t\trayDirection = getHemisphereSample( floorNormal, rand2() );\n\t\t\t\t\t\t\t\tthroughputColor *= floorColor / PI;\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t#if GRADIENT_BG\n\n\t\t\t\t\t\t\tif ( i == 0 ) {\n\n\t\t\t\t\t\t\t\trayDirection = normalize( rayDirection );\n\t\t\t\t\t\t\t\tfloat value = ( rayDirection.y + 1.0 ) / 2.0;\n\n\t\t\t\t\t\t\t\tvalue = pow( value, 2.0 );\n\n\t\t\t\t\t\t\t\tgl_FragColor = vec4( mix( bgGradientBottom, bgGradientTop, value ), 1.0 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t#if USE_ENVMAP\n\n                            vec3 skyColor = textureCubeUV( environmentMap, rayDirection, environmentBlur ).rgb;\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\trayDirection = normalize( rayDirection );\n\t\t\t\t\t\t\tfloat value = ( rayDirection.y + 1.0 ) / 2.0;\n\t\t\t\t\t\t\tvec3 skyColor = mix( gradientBottom, gradientTop, value );\n\n\t\t\t\t\t\t\t#endif\n\n                            gl_FragColor += vec4( skyColor * throughputColor * environmentIntensity, 1.0 );\n\n                            break;\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = materials[ materialIndex ];\n\n\t\t\t\t\t\tif ( material.opacity < rand() ) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\trayOrigin += rayDirection * dist - faceNormal * RAY_OFFSET;\n\t\t\t\t\t\t\tthroughputColor *= mix( vec3( 1.0 ), material.color, 0.5 * material.opacity );\n\n\t\t\t\t\t\t\ti --;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n                        // fetch the interpolated smooth normal\n                        vec3 normal = normalize( textureSampleBarycoord(\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t).xyz );\n\n\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\n\n\t\t\t\t\t\t// emission\n\t\t\t\t\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\t\t\t\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\t\t\t\t\temission *= texture2D( textures, vec3( uv, material.emissiveMap ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl_FragColor.rgb += throughputColor * emission * max( side, 0.0 );\n\n\t\t\t\t\t\t// 1 / PI attenuation for physically correct lambert model\n                        // https://www.rorydriscoll.com/2009/01/25/energy-conservation-in-games/\n                        throughputColor *= 1.0 / PI;\n\n\t\t\t\t\t\t// albedo\n\t\t\t\t\t\tthroughputColor *= material.color;\n\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\tthroughputColor *= texture2D( textures, vec3( uv, material.map ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\ttangentAttribute,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uv, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\t\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormal *= side;\n\n                        // adjust the hit point by the surface normal by a factor of some offset and the\n                        // maximum component-wise value of the current point to accommodate floating point\n                        // error as values increase.\n                        vec3 point = rayOrigin + rayDirection * dist;\n                        vec3 absPoint = abs( point );\n                        float maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n                        rayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * RAY_OFFSET;\n                        rayDirection = getHemisphereSample( normal, rand2() );\n\n\t\t\t\t\t\t// if the surface normal is skewed such that the outgoing vector can wind up underneath\n\t\t\t\t\t\t// the triangle surface then just consider it absorbed.\n\t\t\t\t\t\tif ( dot( rayDirection, faceNormal ) < 0.0 ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\n                    }\n\n\t\t\t\t\t// gl_FragColor.rgb = mix( gl_FragColor.rgb / 2.0, gl_FragColor.rgb, clamp( float( i ), 0.0, 1.0 ) );\n\t\t\t\t\t// gl_FragColor.rgb = mix( textureCubeUV( environmentMap, rayDirection, 0.0 ).rgb, gl_FragColor.rgb, clamp( float( i ), 0.0, 1.0 ) );\n                    gl_FragColor.a = opacity;\n\n                }\n\n            `});for(const t in this.uniforms)Object.defineProperty(this,t,{get(){return this.uniforms[t].value},set(e){this.uniforms[t].value=e}});this.setValues(t)}setDefine(t,e){null==e?t in this.defines&&(delete this.defines[t],this.needsUpdate=!0):this.defines[t]!==e&&(this.defines[t]=e,this.needsUpdate=!0)}}function F(t){return t.buffer instanceof ArrayBuffer&&"BYTES_PER_ELEMENT"in t}class P{constructor(){const t=new Set;t.add("uuid"),this.ignoreKeys=t,this.shareTextures=!0,this.textures=[],this.materials=[]}areEqual(t,e){const n=new Set,r=new Set,a=this.ignoreKeys,i=(t,e)=>{if(t===e)return!0;if(t&&e&&t instanceof Object&&e instanceof Object){if(r.has(t)||r.has(e))throw new Error("MaterialReducer: Material is recursive.");const o=t instanceof Element,s=e instanceof Element;if(o||s)return o===s&&t instanceof Image&&e instanceof Image&&t.src===e.src;const l=t instanceof ImageBitmap,c=e instanceof ImageBitmap;if(l||c)return!1;if(t.equals)return t.equals(e);const d=F(t),u=F(e);if(d||u){if(d!==u||t.constructor!==e.constructor||t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n++)if(t[n]!==e[n])return!1;return!0}r.add(t),r.add(e),n.clear();for(const e in t)!t.hasOwnProperty(e)||t[e]instanceof Function||a.has(e)||n.add(e);for(const t in e)!e.hasOwnProperty(t)||e[t]instanceof Function||a.has(t)||n.add(t);const h=Array.from(n.values());let m=!0;for(const n in h){const r=h[n];if(!a.has(r)&&(m=i(t[r],e[r]),!m))break}return r.delete(t),r.delete(e),m}return!1};return i(t,e)}process(t){const{textures:e,materials:n}=this;let r=0;const a=t=>{let a=null;for(const e in n){const r=n[e];this.areEqual(t,r)&&(a=r)}if(a)return r++,a;if(n.push(t),this.shareTextures)for(const n in t){if(!t.hasOwnProperty(n))continue;const r=t[n];if(r&&r.isTexture&&r.image instanceof Image){let a=null;for(const t in e){const n=e[t];if(this.areEqual(n,r)){a=n;break}}a?t[n]=a:e.push(r)}}return t};return t.traverse((t=>{if(t.isMesh&&t.material){const e=t.material;if(Array.isArray(e))for(let t=0;t<e.length;t++)e[t]=a(e[t]);else t.material=a(e)}})),{replaced:r,retained:n.length}}}var I=function(){var t=0,e=document.createElement("div");function n(t){return e.appendChild(t.dom),t}function r(n){for(var r=0;r<e.children.length;r++)e.children[r].style.display=r===n?"block":"none";t=n}e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",(function(n){n.preventDefault(),r(++t%e.children.length)}),!1);var a=(performance||Date).now(),i=a,o=0,s=n(new I.Panel("FPS","#0ff","#002")),l=n(new I.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=n(new I.Panel("MB","#f08","#201"));return r(0),{REVISION:16,dom:e,addPanel:n,showPanel:r,begin:function(){a=(performance||Date).now()},end:function(){o++;var t=(performance||Date).now();if(l.update(t-a,200),t>=i+1e3&&(s.update(1e3*o/(t-i),100),i=t,o=0,c)){var e=performance.memory;c.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){a=this.end()},domElement:e,setMode:r}};I.Panel=function(t,e,n){var r=1/0,a=0,i=Math.round,o=i(window.devicePixelRatio||1),s=80*o,l=48*o,c=3*o,d=2*o,u=3*o,h=15*o,m=74*o,p=30*o,g=document.createElement("canvas");g.width=s,g.height=l,g.style.cssText="width:80px;height:48px";var f=g.getContext("2d");return f.font="bold "+9*o+"px Helvetica,Arial,sans-serif",f.textBaseline="top",f.fillStyle=n,f.fillRect(0,0,s,l),f.fillStyle=e,f.fillText(t,c,d),f.fillRect(u,h,m,p),f.fillStyle=n,f.globalAlpha=.9,f.fillRect(u,h,m,p),{dom:g,update:function(l,b){r=Math.min(r,l),a=Math.max(a,l),f.fillStyle=n,f.globalAlpha=1,f.fillRect(0,0,s,h),f.fillStyle=e,f.fillText(i(l)+" "+t+" ("+i(r)+"-"+i(a)+")",c,d),f.drawImage(g,u+o,h,m-o,p,u,h,m-o,p),f.fillRect(u+m-o,h,o,p),f.fillStyle=n,f.globalAlpha=.9,f.fillRect(u+m-o,h,o,i((1-l/b)*p))}}};var N=I;const O=document.getElementById("credits"),B=document.getElementById("loading"),V=document.getElementById("samples"),G=new class{get domElement(){return this._container}constructor(){this.scene=new a.Scene,this.camera=new a.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.025,500),this.camera.position.set(1,.5,1),this.renderer=new a.WebGLRenderer({antialias:!0}),this.fsQuad=new S.FullScreenQuad(new a.MeshBasicMaterial({transparent:!0})),this.ptRenderer=new E.PathTracingRenderer(this.renderer),this.ptModel=null,this.ptMaterials=null,this.ptTextures=null,this.model=null,this.bvhGenerator=new T.GenerateMeshBVHWorker,this.onRender=null,this.enablePathTracing=!0,this.pausePathTracing=!1,this.samplesPerFrame=1,this._scale=1,this._nextObject=null,this._needsSizeUpdate=!1,this._newSize=new a.Vector2,this._resizeObserver=new ResizeObserver((t=>{const{contentRect:e}=t[0];this._newSize.set(e.width,e.height),this._needsSizeUpdate=!0}));const t=document.createElement("div");t.style.overflow="hidden",t.appendChild(this.renderer.domElement),this._container=t,this.ptRenderer.camera=this.camera,this.ptRenderer.material=new R({transparent:!0,depthWrite:!1}),this.renderer.outputEncoding=a.sRGBEncoding,this._resizeObserver.observe(t)}_updateSize(){const t=window.devicePixelRatio,e=this._scale,n=this._newSize;this.renderer.setPixelRatio(t),this.renderer.domElement.style.aspectRatio=`${n.width} / ${n.height}`,this.renderer.domElement.style.width="100%",this.renderer.setSize(e*n.width,e*n.height,!1),this.ptRenderer.target.setSize(n.width*e*t,n.height*e*t),this.camera.aspect=n.width/n.height,this.camera.updateProjectionMatrix(),this._needsSizeUpdate=!1}setScale(t){this._scale=t,this._needsSizeUpdate=!0}setModel(t,e={}){if(this.bvhGenerator.running)return void(this._nextObject=t);t.updateMatrixWorld(!0);(new P).process(t);const n=[];t.traverse((t=>{t.isMesh&&n.push(t)}));const{geometry:r,materials:i,textures:o}=_.mergeMeshes(n,{attributes:["position","normal","tangent","uv"]});return this.bvhGenerator.generate(r,{strategy:L.SAH,maxLeafTris:1,...e}).then((e=>{if(this._nextObject)return this.setModel(this._nextObject),void(this._nextObject=null);this.model&&(this.scene.remove(this.model),this.ptTextures.forEach((t=>t.dispose())),this.ptMaterials.forEach((t=>t.dispose())));const n=new a.Mesh(r);this.scene.add(t),this.ptModel=n,this.ptMaterials=i,this.ptTextures=o,this.model=t;const{ptRenderer:s}=this,{material:l}=s;l.bvh.dispose(),l.normalAttribute.dispose(),l.tangentAttribute.dispose(),l.uvAttribute.dispose(),l.materialIndexAttribute.dispose(),l.textures.dispose(),l.bvh.updateFrom(e),l.normalAttribute.updateFrom(r.attributes.normal),l.tangentAttribute.updateFrom(r.attributes.tangent),l.uvAttribute.updateFrom(r.attributes.uv),l.materialIndexAttribute.updateFrom(r.attributes.materialIndex),l.textures.setTextures(this.renderer,2048,2048,o),l.materials.updateFrom(i,o),l.setDefine("MATERIAL_LENGTH",i.length),s.reset()}))}setEnvironment(t){this.scene.environment=t}init(){const{ptRenderer:t,renderer:e,fsQuad:n,camera:r}=this,a=new C.OrbitControls(r,e.domElement);let i=0;a.addEventListener("change",(()=>{const e=this.ptRenderer.tiles;e.x*e.y!=1&&(i=1),t.reset()})),e.setAnimationLoop((()=>{if(!this.pausePathTracing){if(this._needsSizeUpdate&&(this._updateSize(),this.ptRenderer.reset()),this.model)if(this.enablePathTracing&&0===i){r.updateMatrixWorld();for(let e=0,n=this.samplesPerFrame;e<n;e++)t.update();t.samples<1&&e.render(this.scene,this.camera),e.autoClear=!1,n.material.map=t.target.texture,n.render(e),e.autoClear=!0}else i>0&&i--,e.render(this.scene,this.camera);else e.clear();this.onRender&&this.onRender()}}))}};G.init(),G.domElement.style.width="100%",G.domElement.style.height="100%",document.body.appendChild(G.domElement);const z={"Royal Esplanade":"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/royal_esplanade_1k.hdr","Moonless Golf":"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/moonless_golf_1k.hdr",Overpass:"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/pedestrian_overpass_1k.hdr","Venice Sunset":"https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr"},j=window.MODEL_LIST||{"M2020 Rover":{url:"https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/nasa-m2020/Perseverance.glb",credit:"Model credit NASA / JPL-Caltech"},"Neko Stop Diorama":{url:"https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/neko-stop-diorama/scene.gltf",credit:'Model by "Art by Kidd" on Sketchfab.',rotation:[0,1.15*Math.PI/4,0],removeEmission:!0},"Japanese Temple":{url:"https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/japanese-temple/scene.gltf",credit:'Japanese Temple Model by "Aditya Graphical" on Sketchfab.'},Statue:{url:"https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/threedscans/Le_Transi_De_Rene_De_Chalon.glb",credit:"Model courtesy of threedscans.com."},"Crab Sculpture":{url:"https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/threedscans/Elbow_Crab.glb",rotation:[3.1*Math.PI/4,Math.PI,0],credit:"Model courtesy of threedscans.com."},"Stylized Carriage":{url:"https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/wooden-stylised-carriage/scene.gltf",credit:'Model by "LamedeFeu" on Sketchfab.'}},U={acesToneMapping:!0,resolutionScale:.75/window.devicePixelRatio,tilesX:2,tilesY:2,samplesPerFrame:1,model:Object.keys(j)[0],environment:"ENVMAP",envMap:z["Royal Esplanade"],gradientTop:"#bfd8ff",gradientBottom:"#ffffff",environmentIntensity:3,environmentBlur:.35,backgroundType:"Gradient",bgGradientTop:"#111111",bgGradientBottom:"#000000",enable:!0,bounces:3,floorColor:"#080808",floorEnabled:!0};let W=null;function H(){(new o.RGBELoader).load(U.envMap,(t=>{G.ptRenderer.material.environmentMap&&(G.ptRenderer.material.environmentMap.dispose(),G.scene.environment.dispose());const e=new a.PMREMGenerator(G.renderer);e.compileCubemapShader();const n=e.fromEquirectangular(t);t.mapping=a.EquirectangularReflectionMapping,G.ptRenderer.material.environmentIntensity=parseFloat(U.environmentIntensity),G.ptRenderer.material.environmentMap=n.texture,G.scene.environment=t,"Gradient"!==U.backgroundType&&(G.scene.background=t),G.ptRenderer.reset()}))}async function q(){let t;W&&(W.destroy(),W=null);const e=new a.LoadingManager,n=j[U.model];G.pausePathTracing=!0,G.renderer.domElement.style.visibility="hidden",V.innerText="--",O.innerText="--",B.innerText="Loading",B.style.visibility="visible";const r=async()=>{n.rotation&&t.rotation.set(...n.rotation),n.removeEmission&&t.traverse((t=>{t.material&&(t.material.emissiveMap=null,t.material.emissiveIntensity=0)})),t.traverse((t=>{if(t.material){t.material.side=a.DoubleSide,t.material.opacity<1&&(t.material.opacity*=.75);const e={};t.material.color.getHSL(e),e.l<.025&&(e.l=.025,t.material.color.setHSL(e.h,e.s,e.l))}}));const e=new a.Box3;e.setFromObject(t),t.position.addScaledVector(e.min,-.5).addScaledVector(e.max,-.5);const r=new a.Sphere;e.getBoundingSphere(r),t.scale.setScalar(1/r.radius),t.position.multiplyScalar(1/r.radius),await G.setModel(t,{onProgress:t=>{const e=Math.floor(100*t);B.innerText=`Building BVH : ${e}%`}}),B.style.visibility="hidden",O.innerHTML=n.credit||"",O.style.visibility=n.credit?"visible":"hidden",function(){W&&W.destroy(),W=new x.GUI,W.add(U,"model",Object.keys(j)).onChange(q);const t=W.addFolder("resolution");t.add(U,"resolutionScale",.1,1,.01).onChange((t=>{G.setScale(parseFloat(t))})),t.add(U,"samplesPerFrame",1,10,1).onChange((t=>{G.samplesPerFrame=parseInt(t)})),t.add(U,"tilesX",1,10,1).onChange((t=>{G.ptRenderer.tiles.x=parseInt(t)})),t.add(U,"tilesY",1,10,1).onChange((t=>{G.ptRenderer.tiles.y=parseInt(t)})),t.open();const e=W.addFolder("environment");e.add(U,"envMap",z).name("map").onChange(H),e.add(U,"environmentBlur",0,1,.01).onChange((t=>{G.ptRenderer.material.environmentBlur=parseFloat(t),G.ptRenderer.reset()})).name("env map blur"),e.add(U,"environmentIntensity",0,10,.01).onChange((t=>{G.ptRenderer.material.environmentIntensity=parseFloat(t),G.ptRenderer.reset()})).name("intensity"),e.open();const n=W.addFolder("background");n.add(U,"backgroundType",["Environment","Gradient"]).onChange((t=>{G.ptRenderer.material.setDefine("GRADIENT_BG",Number("Gradient"===t)),G.scene.background="Gradient"===t?new a.Color(394758):G.scene.environment,G.ptRenderer.reset()})),n.addColor(U,"bgGradientTop").onChange((t=>{G.ptRenderer.material.uniforms.bgGradientTop.value.set(t),G.ptRenderer.reset()})),n.addColor(U,"bgGradientBottom").onChange((t=>{G.ptRenderer.material.uniforms.bgGradientBottom.value.set(t),G.ptRenderer.reset()})),n.open();const r=W.addFolder("floor");r.add(U,"floorEnabled").onChange((t=>{G.ptRenderer.material.setDefine("DISPLAY_FLOOR",Number(t)),G.ptRenderer.reset()})),r.addColor(U,"floorColor").onChange((t=>{G.ptRenderer.material.uniforms.floorColor.value.set(t),G.ptRenderer.reset()}));const i=W.addFolder("path tracing");i.add(U,"enable").onChange((t=>{G.enablePathTracing=t})),i.add(U,"acesToneMapping").onChange((t=>{G.renderer.toneMapping=t?a.ACESFilmicToneMapping:a.NoToneMapping,G.fsQuad.material.needsUpdate=!0})),i.add(U,"bounces",1,20,1).onChange((t=>{G.ptRenderer.material.setDefine("BOUNCES",parseInt(t)),G.ptRenderer.reset()})),i.open()}(),G.pausePathTracing=!1,G.renderer.domElement.style.visibility="visible",G.ptRenderer.material.uniforms.floorHeight.value=-(e.max.y-e.min.y)/(2*r.radius)},o=n.url;if(/(gltf|glb)$/i.test(o))e.onLoad=r,new s.GLTFLoader(e).setMeshoptDecoder(i.MeshoptDecoder).load(o,(e=>{t=e.scene}),(t=>{if(0!==t.total&&t.total>=t.loaded){const e=Math.floor(100*t.loaded/t.total);B.innerText=`Loading : ${e}%`}}));else if(/mpd$/i.test(o)){e.onProgress=(t,e,n)=>{const r=Math.floor(100*e/n);B.innerText=`Loading : ${r}%`};const n=new w(e);await n.preloadMaterials("https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/colors/ldcfgalt.ldr"),n.setPartsLibraryPath("https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/complete/ldraw/").load(o,(e=>{t=class{static mergeObject(t){function e(t,e,n,r){const i=new a.BufferGeometry,o=t.getAttribute("position").array,s=3===n?t.getAttribute("normal").array:null,l=Math.min(e.count,Math.floor(o.length/3)-e.start),c=3*e.start,d=3*(e.start+l),u=o.subarray(c,d),h=null!==s?s.subarray(c,d):null;if(i.setAttribute("position",new a.BufferAttribute(u,3)),null!==h&&i.setAttribute("normal",new a.BufferAttribute(h,3)),r){const e=t.getAttribute("control0").array.subarray(c,d),n=t.getAttribute("control1").array.subarray(c,d),r=t.getAttribute("direction").array.subarray(c,d);i.setAttribute("control0",new a.BufferAttribute(e,3,!1)),i.setAttribute("control1",new a.BufferAttribute(n,3,!1)),i.setAttribute("direction",new a.BufferAttribute(r,3,!1))}return i}function n(t,e,n){const r=n[t.uuid];r?r.arr.push(e):n[t.uuid]={mat:t,arr:[e]}}function r(t,e){if(!t)return;const n=t.array,r=Math.floor(n.length/3);let a=0;for(let t=0;t<r;t++){const t=n[a],r=n[a+1],i=n[a+2];n[a]=n[a+3],n[a+1]=n[a+4],n[a+2]=n[a+5],n[a+3]=t,n[a+4]=r,n[a+5]=i,a+=3*e}}const i={},o={},s={};t.updateMatrixWorld(!0);const l=new a.Matrix3;t.traverse((t=>{if(t.isMesh|t.isLineSegments){const a=t.isMesh?3:2,c=t.geometry.clone();t.matrixWorld.determinant()<0&&(r(c.attributes.position,a),r(c.attributes.normal,a)),c.applyMatrix4(t.matrixWorld),t.isConditionalLine&&(c.attributes.control0.applyMatrix4(t.matrixWorld),c.attributes.control1.applyMatrix4(t.matrixWorld),l.getNormalMatrix(t.matrixWorld),c.attributes.direction.applyNormalMatrix(l));const d=t.isMesh?i:t.isConditionalLine?s:o;if(Array.isArray(t.material))for(const r in c.groups){const i=c.groups[r];n(t.material[i.materialIndex],e(c,i,a,t.isConditionalLine),d)}else n(t.material,c,d)}}));const c=new a.Group,d=Object.keys(i);for(const t in d){const e=i[d[t]],n=M.mergeBufferGeometries(e.arr);c.add(new a.Mesh(n,e.mat))}const u=Object.keys(o);for(const t in u){const e=o[u[t]],n=M.mergeBufferGeometries(e.arr);c.add(new a.LineSegments(n,e.mat))}const h=Object.keys(s);for(const t in h){const e=s[h[t]],n=M.mergeBufferGeometries(e.arr),r=new a.LineSegments(n,e.mat);r.isConditionalLine=!0,c.add(r)}return c.userData.constructionStep=0,c.userData.numConstructionSteps=1,c}}.mergeObject(e),t.rotation.set(Math.PI,0,0),t.traverse((t=>{t.isLineSegments&&(t.visible=!1)})),r()}))}}const Y=new N;document.body.appendChild(Y.dom),G.renderer.physicallyCorrectLights=!0,G.renderer.toneMapping=a.ACESFilmicToneMapping,G.ptRenderer.material.setDefine("GRADIENT_BG",1),G.scene.background=new a.Color(394758),G.ptRenderer.tiles.set(U.tilesX,U.tilesY),G.setScale(U.resolutionScale),G.onRender=()=>{Y.update();const t=Math.floor(G.ptRenderer.samples);V.innerText=`samples: ${t}`},q(),H();
//# sourceMappingURL=lambert.adc0673f.js.map
