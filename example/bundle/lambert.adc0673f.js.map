{"mappings":"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","sources":["example/lambert.js","node_modules/three/examples/jsm/loaders/LDrawLoader.js","node_modules/three/examples/jsm/utils/LDrawUtils.js","src/viewers/PathTracingViewer.js","src/materials/LambertPathTracingMaterial.js","src/core/MaterialReducer.js","node_modules/three/examples/jsm/libs/stats.module.js"],"sourcesContent":["import { ACESFilmicToneMapping, NoToneMapping, Box3, LoadingManager, EquirectangularReflectionMapping, PMREMGenerator, Sphere, Color, DoubleSide } from 'three';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { LDrawLoader } from 'three/examples/jsm/loaders/LDrawLoader.js';\nimport { LDrawUtils } from 'three/examples/jsm/utils/LDrawUtils.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { PathTracingViewer } from '../src/viewers/PathTracingViewer.js';\nimport Stats from 'three/examples/jsm/libs/stats.module.js';\n\nconst creditEl = document.getElementById( 'credits' );\nconst loadingEl = document.getElementById( 'loading' );\nconst samplesEl = document.getElementById( 'samples' );\n\nconst viewer = new PathTracingViewer();\nviewer.init();\nviewer.domElement.style.width = '100%';\nviewer.domElement.style.height = '100%';\ndocument.body.appendChild( viewer.domElement );\n\nconst envMaps = {\n\t'Royal Esplanade': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/royal_esplanade_1k.hdr',\n\t'Moonless Golf': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/moonless_golf_1k.hdr',\n\t'Overpass': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/pedestrian_overpass_1k.hdr',\n\t'Venice Sunset': 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr',\n};\n\nconst models = window.MODEL_LIST || {\n\t'M2020 Rover': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/nasa-m2020/Perseverance.glb',\n\t\tcredit: 'Model credit NASA / JPL-Caltech',\n\t},\n\t'Neko Stop Diorama': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/neko-stop-diorama/scene.gltf',\n\t\tcredit: 'Model by \"Art by Kidd\" on Sketchfab.',\n\t\trotation: [ 0, 1.15 * Math.PI / 4, 0 ],\n\t\tremoveEmission: true,\n\t},\n\t'Japanese Temple': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/japanese-temple/scene.gltf',\n\t\tcredit: 'Japanese Temple Model by \"Aditya Graphical\" on Sketchfab.',\n\t},\n\t'Statue': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/threedscans/Le_Transi_De_Rene_De_Chalon.glb',\n\t\tcredit: 'Model courtesy of threedscans.com.',\n\t},\n\t'Crab Sculpture': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/threedscans/Elbow_Crab.glb',\n\t\trotation: [ 3.1 * Math.PI / 4, Math.PI, 0 ],\n\t\tcredit: 'Model courtesy of threedscans.com.',\n\t},\n\t'Stylized Carriage': {\n\t\turl: 'https://raw.githubusercontent.com/gkjohnson/gltf-demo-models/main/wooden-stylised-carriage/scene.gltf',\n\t\tcredit: 'Model by \"LamedeFeu\" on Sketchfab.',\n\t},\n\n};\n\nconst params = {\n\n\tacesToneMapping: true,\n\tresolutionScale: 0.75 / window.devicePixelRatio,\n\ttilesX: 2,\n\ttilesY: 2,\n\tsamplesPerFrame: 1,\n\n\tmodel: Object.keys( models )[ 0 ],\n\n\tenvironment: 'ENVMAP',\n\tenvMap: envMaps[ 'Royal Esplanade' ],\n\n\tgradientTop: '#bfd8ff',\n\tgradientBottom: '#ffffff',\n\n\tenvironmentIntensity: 3.0,\n\tenvironmentBlur: 0.35,\n\n\tbackgroundType: 'Gradient',\n\tbgGradientTop: '#111111',\n\tbgGradientBottom: '#000000',\n\n\tenable: true,\n\tbounces: 3,\n\n\tfloorColor: '#080808',\n\tfloorEnabled: true,\n\n};\n\nlet gui = null;\nfunction buildGui() {\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\n\t}\n\n\tgui = new GUI();\n\n\tgui.add( params, 'model', Object.keys( models ) ).onChange( updateModel );\n\n\tconst resolutionFolder = gui.addFolder( 'resolution' );\n\tresolutionFolder.add( params, 'resolutionScale', 0.1, 1.0, 0.01 ).onChange( v => {\n\n\t\tviewer.setScale( parseFloat( v ) );\n\n\t} );\n\tresolutionFolder.add( params, 'samplesPerFrame', 1, 10, 1 ).onChange( v => {\n\n\t\tviewer.samplesPerFrame = parseInt( v );\n\n\t} );\n\tresolutionFolder.add( params, 'tilesX', 1, 10, 1 ).onChange( v => {\n\n\t\tviewer.ptRenderer.tiles.x = parseInt( v );\n\n\t} );\n\tresolutionFolder.add( params, 'tilesY', 1, 10, 1 ).onChange( v => {\n\n\t\tviewer.ptRenderer.tiles.y = parseInt( v );\n\n\t} );\n\tresolutionFolder.open();\n\n\tconst environmentFolder = gui.addFolder( 'environment' );\n\tenvironmentFolder.add( params, 'envMap', envMaps ).name( 'map' ).onChange( updateEnvMap );\n\tenvironmentFolder.add( params, 'environmentBlur', 0.0, 1.0, 0.01 ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.environmentBlur = parseFloat( v );\n\t\tviewer.ptRenderer.reset();\n\n\t} ).name( 'env map blur' );\n\tenvironmentFolder.add( params, 'environmentIntensity', 0.0, 10.0, 0.01 ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.environmentIntensity = parseFloat( v );\n\t\tviewer.ptRenderer.reset();\n\n\t} ).name( 'intensity' );\n\tenvironmentFolder.open();\n\n\tconst backgroundFolder = gui.addFolder( 'background' );\n\tbackgroundFolder.add( params, 'backgroundType', [ 'Environment', 'Gradient' ] ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.setDefine( 'GRADIENT_BG', Number( v === 'Gradient' ) );\n\t\tif ( v === 'Gradient' ) {\n\n\t\t\tviewer.scene.background = new Color( 0x060606 );\n\n\t\t} else {\n\n\t\t\tviewer.scene.background = viewer.scene.environment;\n\n\t\t}\n\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\tbackgroundFolder.addColor( params, 'bgGradientTop' ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.uniforms.bgGradientTop.value.set( v );\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\tbackgroundFolder.addColor( params, 'bgGradientBottom' ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.uniforms.bgGradientBottom.value.set( v );\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\tbackgroundFolder.open();\n\n\tconst floorFolder = gui.addFolder( 'floor' );\n\tfloorFolder.add( params, 'floorEnabled' ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.setDefine( 'DISPLAY_FLOOR', Number( v ) );\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\tfloorFolder.addColor( params, 'floorColor' ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.uniforms.floorColor.value.set( v );\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\n\tconst pathTracingFolder = gui.addFolder( 'path tracing' );\n\tpathTracingFolder.add( params, 'enable' ).onChange( v => {\n\n\t\tviewer.enablePathTracing = v;\n\n\t} );\n\tpathTracingFolder.add( params, 'acesToneMapping' ).onChange( v => {\n\n\t\tviewer.renderer.toneMapping = v ? ACESFilmicToneMapping : NoToneMapping;\n\t\tviewer.fsQuad.material.needsUpdate = true;\n\n\t} );\n\tpathTracingFolder.add( params, 'bounces', 1, 20, 1 ).onChange( v => {\n\n\t\tviewer.ptRenderer.material.setDefine( 'BOUNCES', parseInt( v ) );\n\t\tviewer.ptRenderer.reset();\n\n\t} );\n\tpathTracingFolder.open();\n\n}\n\nfunction updateEnvMap() {\n\n\tnew RGBELoader()\n\t\t.load( params.envMap, texture => {\n\n\t\t\tif ( viewer.ptRenderer.material.environmentMap ) {\n\n\t\t\t\tviewer.ptRenderer.material.environmentMap.dispose();\n\t\t\t\tviewer.scene.environment.dispose();\n\n\t\t\t}\n\n\t\t\tconst pmremGenerator = new PMREMGenerator( viewer.renderer );\n\t\t\tpmremGenerator.compileCubemapShader();\n\n\t\t\tconst envMap = pmremGenerator.fromEquirectangular( texture );\n\n\t\t\ttexture.mapping = EquirectangularReflectionMapping;\n\t\t\tviewer.ptRenderer.material.environmentIntensity = parseFloat( params.environmentIntensity );\n\t\t\tviewer.ptRenderer.material.environmentMap = envMap.texture;\n\t\t\tviewer.scene.environment = texture;\n\t\t\tif ( params.backgroundType !== 'Gradient' ) {\n\n\t\t\t\tviewer.scene.background = texture;\n\n\t\t\t}\n\n\t\t\tviewer.ptRenderer.reset();\n\n\t\t} );\n\n}\n\nasync function updateModel() {\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\t\tgui = null;\n\n\t}\n\n\tlet model;\n\tconst manager = new LoadingManager();\n\tconst modelInfo = models[ params.model ];\n\n\tviewer.pausePathTracing = true;\n\tviewer.renderer.domElement.style.visibility = 'hidden';\n\tsamplesEl.innerText = '--';\n\tcreditEl.innerText = '--';\n\tloadingEl.innerText = 'Loading';\n\tloadingEl.style.visibility = 'visible';\n\n\tconst onFinish = async () => {\n\n\t\tif ( modelInfo.rotation ) {\n\n\t\t\tmodel.rotation.set( ...modelInfo.rotation );\n\n\t\t}\n\n\t\tif ( modelInfo.removeEmission ) {\n\n\t\t\tmodel.traverse( c => {\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tc.material.emissiveMap = null;\n\t\t\t\t\tc.material.emissiveIntensity = 0;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tc.material.side = DoubleSide;\n\n\t\t\t\tif ( c.material.opacity < 1 ) {\n\n\t\t\t\t\t// small hack to account for double sidedness making geometry look more opaque than intended\n\t\t\t\t\tc.material.opacity *= 0.75;\n\n\t\t\t\t}\n\n\t\t\t\t// boost particularly dark colors because all detail is lost with\n\t\t\t\t// dark lambert shading\n\t\t\t\tconst hsl = {};\n\t\t\t\tc.material.color.getHSL( hsl );\n\t\t\t\tif ( hsl.l < 0.025 ) {\n\n\t\t\t\t\thsl.l = 0.025;\n\t\t\t\t\tc.material.color.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// center the model\n\t\tconst box = new Box3();\n\t\tbox.setFromObject( model );\n\t\tmodel.position\n\t\t\t.addScaledVector( box.min, - 0.5 )\n\t\t\t.addScaledVector( box.max, - 0.5 );\n\n\t\tconst sphere = new Sphere();\n\t\tbox.getBoundingSphere( sphere );\n\n\t\tmodel.scale.setScalar( 1 / sphere.radius );\n\t\tmodel.position.multiplyScalar( 1 / sphere.radius );\n\n\t\tawait viewer.setModel( model, { onProgress: v => {\n\n\t\t\tconst percent = Math.floor( 100 * v );\n\t\t\tloadingEl.innerText = `Building BVH : ${ percent }%`;\n\n\t\t} } );\n\n\t\tloadingEl.style.visibility = 'hidden';\n\n\t\tcreditEl.innerHTML = modelInfo.credit || '';\n\t\tcreditEl.style.visibility = modelInfo.credit ? 'visible' : 'hidden';\n\t\tbuildGui();\n\n\t\tviewer.pausePathTracing = false;\n\t\tviewer.renderer.domElement.style.visibility = 'visible';\n\t\tviewer.ptRenderer.material.uniforms.floorHeight.value = - ( box.max.y - box.min.y ) / ( 2 * sphere.radius );\n\n\t};\n\n\tconst url = modelInfo.url;\n\tif ( /(gltf|glb)$/i.test( url ) ) {\n\n\t\tmanager.onLoad = onFinish;\n\t\tnew GLTFLoader( manager )\n\t\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t\t.load(\n\t\t\t\turl,\n\t\t\t\tgltf => {\n\n\t\t\t\t\tmodel = gltf.scene;\n\n\t\t\t\t},\n\t\t\t\tprogress => {\n\n\t\t\t\t\tif ( progress.total !== 0 && progress.total >= progress.loaded ) {\n\n\t\t\t\t\t\tconst percent = Math.floor( 100 * progress.loaded / progress.total );\n\t\t\t\t\t\tloadingEl.innerText = `Loading : ${ percent }%`;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t);\n\n\t} else if ( /mpd$/i.test( url ) ) {\n\n\t\tmanager.onProgress = ( url, loaded, total ) => {\n\n\t\t\tconst percent = Math.floor( 100 * loaded / total );\n\t\t\tloadingEl.innerText = `Loading : ${ percent }%`;\n\n\t\t};\n\n\t\tconst loader = new LDrawLoader( manager );\n\t\tawait loader.preloadMaterials( 'https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/colors/ldcfgalt.ldr' );\n\t\tloader\n\t\t\t.setPartsLibraryPath( 'https://raw.githubusercontent.com/gkjohnson/ldraw-parts-library/master/complete/ldraw/' )\n\t\t\t.load(\n\t\t\t\turl,\n\t\t\t\tresult => {\n\n\t\t\t\t\tmodel = LDrawUtils.mergeObject( result );\n\t\t\t\t\tmodel.rotation.set( Math.PI, 0, 0 );\n\t\t\t\t\tmodel.traverse( c => {\n\n\t\t\t\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\t\t\t\tc.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tonFinish();\n\n\t\t\t\t},\n\t\t\t);\n\n\n\t}\n\n\n}\n\nconst stats = new Stats();\ndocument.body.appendChild( stats.dom );\nviewer.renderer.physicallyCorrectLights = true;\nviewer.renderer.toneMapping = ACESFilmicToneMapping;\nviewer.ptRenderer.material.setDefine( 'GRADIENT_BG', 1 );\nviewer.scene.background = new Color( 0x060606 );\nviewer.ptRenderer.tiles.set( params.tilesX, params.tilesY );\nviewer.setScale( params.resolutionScale );\nviewer.onRender = () => {\n\n\tstats.update();\n\tconst samples = Math.floor( viewer.ptRenderer.samples );\n\tsamplesEl.innerText = `samples: ${ samples }`;\n\n};\n\nupdateModel();\nupdateEnvMap();\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMatrix4,\n\tMesh,\n\tMeshStandardMaterial,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector3,\n\tRay\n} from 'three';\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\n\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.fog,\n\t\t\t\t{\n\t\t\t\t\tdiffuse: {\n\t\t\t\t\t\tvalue: new Color()\n\t\t\t\t\t},\n\t\t\t\t\topacity: {\n\t\t\t\t\t\tvalue: 1.0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t\tObject.defineProperties( this, {\n\n\t\t\topacity: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcolor: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\t\tthis.isLDrawConditionalLineMaterial = true;\n\n\t}\n\n}\n\nclass ConditionalLineSegments extends LineSegments {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\t\tthis.isConditionalLine = true;\n\n\t}\n\n}\n\nfunction generateFaceNormals( faces ) {\n\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst face = faces[ i ];\n\t\tconst vertices = face.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\tconst v2 = vertices[ 2 ];\n\n\t\t_tempVec0.subVectors( v1, v0 );\n\t\t_tempVec1.subVectors( v2, v1 );\n\t\tface.faceNormal = new Vector3()\n\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t.normalize();\n\n\t}\n\n}\n\nconst _ray = new Ray();\nfunction smoothNormals( faces, lineSegments, checkSubSegments = false ) {\n\n\t// NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n\t// it allows edges to be smoothed as expected (see minifig arms).\n\t// --\n\t// And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n\t// point errors on vertices along quantization boundaries. Ie after matrix multiplication\n\t// vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n\t// get merged. This added epsilon attempts to push these error values to the same quantized\n\t// value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\n\t\treturn `${ x },${ y },${ z }`;\n\n\t}\n\n\tfunction hashEdge( v0, v1 ) {\n\n\t\treturn `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`;\n\n\t}\n\n\t// converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n\t// onto the original line.\n\tfunction toNormalizedRay( v0, v1, targetRay ) {\n\n\t\ttargetRay.direction.subVectors( v1, v0 ).normalize();\n\n\t\tconst scalar = v0.dot( targetRay.direction );\n\t\ttargetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );\n\n\t\treturn targetRay;\n\n\t}\n\n\tfunction hashRay( ray ) {\n\n\t\treturn hashEdge( ray.origin, ray.direction );\n\n\t}\n\n\tconst hardEdges = new Set();\n\tconst hardEdgeRays = new Map();\n\tconst halfEdgeList = {};\n\tconst normals = [];\n\n\t// Save the list of hard edges by hash\n\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\tconst ls = lineSegments[ i ];\n\t\tconst vertices = ls.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\thardEdges.add( hashEdge( v0, v1 ) );\n\t\thardEdges.add( hashEdge( v1, v0 ) );\n\n\t\t// only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n\t\t// and requires more memory.\n\t\tif ( checkSubSegments ) {\n\n\t\t\t// add both ray directions to the map\n\t\t\tconst ray = toNormalizedRay( v0, v1, new Ray() );\n\t\t\tconst rh1 = hashRay( ray );\n\t\t\tif ( ! hardEdgeRays.has( rh1 ) ) {\n\n\t\t\t\ttoNormalizedRay( v1, v0, ray );\n\t\t\t\tconst rh2 = hashRay( ray );\n\n\t\t\t\tconst info = {\n\t\t\t\t\tray,\n\t\t\t\t\tdistances: [],\n\t\t\t\t};\n\n\t\t\t\thardEdgeRays.set( rh1, info );\n\t\t\t\thardEdgeRays.set( rh2, info );\n\n\t\t\t}\n\n\t\t\t// store both segments ends in min, max order in the distances array to check if a face edge is a\n\t\t\t// subsegment later.\n\t\t\tconst info = hardEdgeRays.get( rh1 );\n\t\t\tlet d0 = info.ray.direction.dot( v0 );\n\t\t\tlet d1 = info.ray.direction.dot( v1 );\n\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t}\n\n\t\t\tinfo.distances.push( d0, d1 );\n\n\t\t}\n\n\t}\n\n\t// track the half edges associated with each triangle\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst tri = faces[ i ];\n\t\tconst vertices = tri.vertices;\n\t\tconst vertCount = vertices.length;\n\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\tconst index = i2;\n\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\tconst v0 = vertices[ index ];\n\t\t\tconst v1 = vertices[ next ];\n\t\t\tconst hash = hashEdge( v0, v1 );\n\n\t\t\t// don't add the triangle if the edge is supposed to be hard\n\t\t\tif ( hardEdges.has( hash ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\t\t\tif ( checkSubSegments ) {\n\n\t\t\t\ttoNormalizedRay( v0, v1, _ray );\n\n\t\t\t\tconst rayHash = hashRay( _ray );\n\t\t\t\tif ( hardEdgeRays.has( rayHash ) ) {\n\n\t\t\t\t\tconst info = hardEdgeRays.get( rayHash );\n\t\t\t\t\tconst { ray, distances } = info;\n\t\t\t\t\tlet d0 = ray.direction.dot( v0 );\n\t\t\t\t\tlet d1 = ray.direction.dot( v1 );\n\n\t\t\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\t\t\t\t\tlet found = false;\n\t\t\t\t\tfor ( let i = 0, l = distances.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tif ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( found ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst info = {\n\t\t\t\tindex: index,\n\t\t\t\ttri: tri\n\t\t\t};\n\t\t\thalfEdgeList[ hash ] = info;\n\n\t\t}\n\n\t}\n\n\t// Iterate until we've tried to connect all faces to share normals\n\twhile ( true ) {\n\n\t\t// Stop if there are no more faces left\n\t\tlet halfEdge = null;\n\t\tfor ( const key in halfEdgeList ) {\n\n\t\t\thalfEdge = halfEdgeList[ key ];\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( halfEdge === null ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\t// Exhaustively find all connected faces\n\t\tconst queue = [ halfEdge ];\n\t\twhile ( queue.length > 0 ) {\n\n\t\t\t// initialize all vertex normals in this triangle\n\t\t\tconst tri = queue.pop().tri;\n\t\t\tconst vertices = tri.vertices;\n\t\t\tconst vertNormals = tri.normals;\n\t\t\tconst faceNormal = tri.faceNormal;\n\n\t\t\t// Check if any edge is connected to another triangle edge\n\t\t\tconst vertCount = vertices.length;\n\t\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\t\tconst index = i2;\n\t\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\t\tconst v0 = vertices[ index ];\n\t\t\t\tconst v1 = vertices[ next ];\n\n\t\t\t\t// delete this triangle from the list so it won't be found again\n\t\t\t\tconst hash = hashEdge( v0, v1 );\n\t\t\t\tdelete halfEdgeList[ hash ];\n\n\t\t\t\tconst reverseHash = hashEdge( v1, v0 );\n\t\t\t\tconst otherInfo = halfEdgeList[ reverseHash ];\n\t\t\t\tif ( otherInfo ) {\n\n\t\t\t\t\tconst otherTri = otherInfo.tri;\n\t\t\t\t\tconst otherIndex = otherInfo.index;\n\t\t\t\t\tconst otherNormals = otherTri.normals;\n\t\t\t\t\tconst otherVertCount = otherNormals.length;\n\t\t\t\t\tconst otherFaceNormal = otherTri.faceNormal;\n\n\t\t\t\t\t// NOTE: If the angle between faces is > 67.5 degrees then assume it's\n\t\t\t\t\t// hard edge. There are some cases where the line segments do not line up exactly\n\t\t\t\t\t// with or span multiple triangle edges (see Lunar Vehicle wheels).\n\t\t\t\t\tif ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if this triangle has already been traversed then it won't be in\n\t\t\t\t\t// the halfEdgeList. If it has not then add it to the queue and delete\n\t\t\t\t\t// it so it won't be found again.\n\t\t\t\t\tif ( reverseHash in halfEdgeList ) {\n\n\t\t\t\t\t\tqueue.push( otherInfo );\n\t\t\t\t\t\tdelete halfEdgeList[ reverseHash ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the first normal\n\t\t\t\t\tconst otherNext = ( otherIndex + 1 ) % otherVertCount;\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ index ] && otherNormals[ otherNext ] &&\n\t\t\t\t\t\tvertNormals[ index ] !== otherNormals[ otherNext ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );\n\t\t\t\t\t\tvertNormals[ index ].norm = otherNormals[ otherNext ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];\n\t\t\t\t\tif ( sharedNormal1 === null ) {\n\n\t\t\t\t\t\t// it's possible to encounter an edge of a triangle that has already been traversed meaning\n\t\t\t\t\t\t// both edges already have different normals defined and shared. To work around this we create\n\t\t\t\t\t\t// a wrapper object so when those edges are merged the normals can be updated everywhere.\n\t\t\t\t\t\tsharedNormal1 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal1.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ index ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ index ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherNext ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherNext ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the second normal\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ next ] && otherNormals[ otherIndex ] &&\n\t\t\t\t\t\tvertNormals[ next ] !== otherNormals[ otherIndex ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );\n\t\t\t\t\t\tvertNormals[ next ].norm = otherNormals[ otherIndex ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];\n\t\t\t\t\tif ( sharedNormal2 === null ) {\n\n\t\t\t\t\t\tsharedNormal2 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal2.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ next ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ next ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherIndex ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// The normals of each face have been added up so now we average them by normalizing the vector.\n\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\tnormals[ i ].normalize();\n\n\t}\n\n}\n\nfunction isPartType( type ) {\n\n\treturn type === 'Part' || type === 'Unofficial_Part';\n\n}\n\nfunction isPrimitiveType( type ) {\n\n\treturn /primitive/i.test( type ) || type === 'Subpart';\n\n}\n\nclass LineParser {\n\n\tconstructor( line, lineNumber ) {\n\n\t\tthis.line = line;\n\t\tthis.lineLength = line.length;\n\t\tthis.currentCharIndex = 0;\n\t\tthis.currentChar = ' ';\n\t\tthis.lineNumber = lineNumber;\n\n\t}\n\n\tseekNonSpace() {\n\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar !== ' ' && this.currentChar !== '\\t' ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t}\n\n\tgetToken() {\n\n\t\tconst pos0 = this.currentCharIndex ++;\n\n\t\t// Seek space\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar === ' ' || this.currentChar === '\\t' ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t\tconst pos1 = this.currentCharIndex;\n\n\t\tthis.seekNonSpace();\n\n\t\treturn this.line.substring( pos0, pos1 );\n\n\t}\n\n\tgetVector() {\n\n\t\treturn new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );\n\n\t}\n\n\tgetRemainingString() {\n\n\t\treturn this.line.substring( this.currentCharIndex, this.lineLength );\n\n\t}\n\n\tisAtTheEnd() {\n\n\t\treturn this.currentCharIndex >= this.lineLength;\n\n\t}\n\n\tsetToEnd() {\n\n\t\tthis.currentCharIndex = this.lineLength;\n\n\t}\n\n\tgetLineNumberString() {\n\n\t\treturn this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n\n\t}\n\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis._cache = {};\n\n\t}\n\n\tcloneResult( original ) {\n\n\t\tconst result = {};\n\n\t\t// vertices are transformed and normals computed before being converted to geometry\n\t\t// so these pieces must be cloned.\n\t\tresult.faces = original.faces.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tnormals: face.normals.map( () => null ),\n\t\t\t\tfaceNormal: null\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.conditionalSegments = original.conditionalSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tcontrolPoints: face.controlPoints.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.lineSegments = original.lineSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\t// none if this is subsequently modified\n\t\tresult.type = original.type;\n\t\tresult.category = original.category;\n\t\tresult.keywords = original.keywords;\n\t\tresult.subobjects = original.subobjects;\n\t\tresult.totalFaces = original.totalFaces;\n\t\tresult.startingConstructionStep = original.startingConstructionStep;\n\t\tresult.materials = original.materials;\n\t\tresult.group = null;\n\t\treturn result;\n\n\t}\n\n\tasync fetchData( fileName ) {\n\n\t\tlet triedLowerCase = false;\n\t\tlet locationState = FILE_LOCATION_AS_IS;\n\t\twhile ( locationState !== FILE_LOCATION_NOT_FOUND ) {\n\n\t\t\tlet subobjectURL = fileName;\n\t\t\tswitch ( locationState ) {\n\n\t\t\t\tcase FILE_LOCATION_AS_IS:\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_PARTS:\n\t\t\t\t\tsubobjectURL = 'parts/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_P:\n\t\t\t\t\tsubobjectURL = 'p/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_MODELS:\n\t\t\t\t\tsubobjectURL = 'models/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_RELATIVE:\n\t\t\t\t\tsubobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_ABSOLUTE:\n\n\t\t\t\t\tif ( triedLowerCase ) {\n\n\t\t\t\t\t\t// Try absolute path\n\t\t\t\t\t\tlocationState = FILE_LOCATION_NOT_FOUND;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Next attempt is lower case\n\t\t\t\t\t\tfileName = fileName.toLowerCase();\n\t\t\t\t\t\tsubobjectURL = fileName;\n\t\t\t\t\t\ttriedLowerCase = true;\n\t\t\t\t\t\tlocationState = FILE_LOCATION_AS_IS;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst loader = this.loader;\n\t\t\tconst fileLoader = new FileLoader( loader.manager );\n\t\t\tfileLoader.setPath( loader.partsLibraryPath );\n\t\t\tfileLoader.setRequestHeader( loader.requestHeader );\n\t\t\tfileLoader.setWithCredentials( loader.withCredentials );\n\n\t\t\ttry {\n\n\t\t\t\tconst text = await fileLoader.loadAsync( subobjectURL );\n\t\t\t\treturn text;\n\n\t\t\t} catch {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new Error( 'LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.' );\n\n\t}\n\n\tparse( text, fileName = null ) {\n\n\t\tconst loader = this.loader;\n\n\t\t// final results\n\t\tconst faces = [];\n\t\tconst lineSegments = [];\n\t\tconst conditionalSegments = [];\n\t\tconst subobjects = [];\n\t\tconst materials = {};\n\n\t\tconst getLocalMaterial = colorCode => {\n\n\t\t\treturn materials[ colorCode ] || null;\n\n\t\t};\n\n\t\tlet type = 'Model';\n\t\tlet category = null;\n\t\tlet keywords = null;\n\t\tlet totalFaces = 0;\n\n\t\t// split into lines\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tconst numLines = lines.length;\n\n\t\tlet parsingEmbeddedFiles = false;\n\t\tlet currentEmbeddedFileName = null;\n\t\tlet currentEmbeddedText = null;\n\n\t\tlet bfcCertified = false;\n\t\tlet bfcCCW = true;\n\t\tlet bfcInverted = false;\n\t\tlet bfcCull = true;\n\n\t\tlet startingConstructionStep = false;\n\n\t\t// Parse all line commands\n\t\tfor ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {\n\n\t\t\tconst line = lines[ lineIndex ];\n\n\t\t\tif ( line.length === 0 ) continue;\n\n\t\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\t\tif ( line.startsWith( '0 FILE ' ) ) {\n\n\t\t\t\t\t// Save previous embedded file in the cache\n\t\t\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t\t\t\t// New embedded text file\n\t\t\t\t\tcurrentEmbeddedFileName = line.substring( 7 );\n\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentEmbeddedText += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst lp = new LineParser( line, lineIndex + 1 );\n\t\t\tlp.seekNonSpace();\n\n\t\t\tif ( lp.isAtTheEnd() ) {\n\n\t\t\t\t// Empty line\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Parse the line type\n\t\t\tconst lineType = lp.getToken();\n\n\t\t\tlet material;\n\t\t\tlet colorCode;\n\t\t\tlet segment;\n\t\t\tlet ccw;\n\t\t\tlet doubleSided;\n\t\t\tlet v0, v1, v2, v3, c0, c1;\n\n\t\t\tswitch ( lineType ) {\n\n\t\t\t\t// Line type 0: Comment or META\n\t\t\t\tcase '0':\n\n\t\t\t\t\t// Parse meta directive\n\t\t\t\t\tconst meta = lp.getToken();\n\n\t\t\t\t\tif ( meta ) {\n\n\t\t\t\t\t\tswitch ( meta ) {\n\n\t\t\t\t\t\t\tcase '!LDRAW_ORG':\n\n\t\t\t\t\t\t\t\ttype = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!COLOUR':\n\n\t\t\t\t\t\t\t\tmaterial = loader.parseColorMetaDirective( lp );\n\t\t\t\t\t\t\t\tif ( material ) {\n\n\t\t\t\t\t\t\t\t\tmaterials[ material.userData.code ] = material;\n\n\t\t\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!CATEGORY':\n\n\t\t\t\t\t\t\t\tcategory = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!KEYWORDS':\n\n\t\t\t\t\t\t\t\tconst newKeywords = lp.getRemainingString().split( ',' );\n\t\t\t\t\t\t\t\tif ( newKeywords.length > 0 ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! keywords ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords = [];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tnewKeywords.forEach( function ( keyword ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords.push( keyword.trim() );\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'FILE':\n\n\t\t\t\t\t\t\t\tif ( lineIndex > 0 ) {\n\n\t\t\t\t\t\t\t\t\t// Start embedded text files parsing\n\t\t\t\t\t\t\t\t\tparsingEmbeddedFiles = true;\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedFileName = lp.getRemainingString();\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t\t\t\t\t\tbfcCertified = false;\n\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'BFC':\n\n\t\t\t\t\t\t\t\t// Changes to the backface culling state\n\t\t\t\t\t\t\t\twhile ( ! lp.isAtTheEnd() ) {\n\n\t\t\t\t\t\t\t\t\tconst token = lp.getToken();\n\n\t\t\t\t\t\t\t\t\tswitch ( token ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'CERTIFY':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCERTIFY':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCertified = token === 'CERTIFY';\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CW':\n\t\t\t\t\t\t\t\t\t\tcase 'CCW':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = token === 'CCW';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'INVERTNEXT':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcInverted = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CLIP':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCLIP':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCull = token === 'CLIP';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.' );\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'STEP':\n\n\t\t\t\t\t\t\t\tstartingConstructionStep = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// Other meta directives are not implemented\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 1: Sub-object file\n\t\t\t\tcase '1':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\n\t\t\t\t\tconst posX = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posY = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posZ = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m0 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m1 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m2 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m3 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m4 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m5 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m6 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m7 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m8 = parseFloat( lp.getToken() );\n\n\t\t\t\t\tconst matrix = new Matrix4().set(\n\t\t\t\t\t\tm0, m1, m2, posX,\n\t\t\t\t\t\tm3, m4, m5, posY,\n\t\t\t\t\t\tm6, m7, m8, posZ,\n\t\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t\t);\n\n\t\t\t\t\tlet fileName = lp.getRemainingString().trim().replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( loader.fileMap[ fileName ] ) {\n\n\t\t\t\t\t\t// Found the subobject path in the preloaded file path map\n\t\t\t\t\t\tfileName = loader.fileMap[ fileName ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Standardized subfolders\n\t\t\t\t\t\tif ( fileName.startsWith( 's/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'parts/' + fileName;\n\n\t\t\t\t\t\t} else if ( fileName.startsWith( '48/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'p/' + fileName;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsubobjects.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tmatrix: matrix,\n\t\t\t\t\t\tfileName: fileName,\n\t\t\t\t\t\tinverted: bfcInverted,\n\t\t\t\t\t\tstartingConstructionStep: startingConstructionStep\n\t\t\t\t\t} );\n\n\t\t\t\t\tbfcInverted = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 2: Line segment\n\t\t\t\tcase '2':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tlineSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 5: Conditional Line segment\n\t\t\t\tcase '5':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\tc0 = lp.getVector();\n\t\t\t\t\tc1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t\tcontrolPoints: [ c0, c1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tconditionalSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 3: Triangle\n\t\t\t\tcase '3':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2 ],\n\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 4: Quadrilateral\n\t\t\t\tcase '4':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv3 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv3 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// specifically place the triangle diagonal in the v0 and v1 slots so we can\n\t\t\t\t\t// account for the doubling of vertices later when smoothing normals.\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2, v3 ],\n\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v3, v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t}\n\n\t\treturn {\n\t\t\tfaces,\n\t\t\tconditionalSegments,\n\t\t\tlineSegments,\n\t\t\ttype,\n\t\t\tcategory,\n\t\t\tkeywords,\n\t\t\tsubobjects,\n\t\t\ttotalFaces,\n\t\t\tstartingConstructionStep,\n\t\t\tmaterials,\n\t\t\tfileName,\n\t\t\tgroup: null\n\t\t};\n\n\t}\n\n\t// returns an (optionally cloned) instance of the data\n\tgetData( fileName, clone = true ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tconst result = this._cache[ key ];\n\t\tif ( result === null || result instanceof Promise ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( clone ) {\n\n\t\t\treturn this.cloneResult( result );\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n\t// the data is ready to use and can be retrieved synchronously with \"getData\".\n\tasync ensureDataLoaded( fileName ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( ! ( key in this._cache ) ) {\n\n\t\t\t// replace the promise with a copy of the parsed data for immediate processing\n\t\t\tthis._cache[ key ] = this.fetchData( fileName ).then( text => {\n\n\t\t\t\tconst info = this.parse( text, fileName );\n\t\t\t\tthis._cache[ key ] = info;\n\t\t\t\treturn info;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tawait this._cache[ key ];\n\n\t}\n\n\t// sets the data in the cache from parsed data\n\tsetData( fileName, text ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tthis._cache[ key ] = this.parse( text, fileName );\n\n\t}\n\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {\n\n\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\tif ( isPassthrough ) {\n\n\t\tcolorCode = parentColorCode;\n\n\t}\n\n\treturn materialHierarchy[ colorCode ] || null;\n\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis.parseCache = new LDrawParsedCache( loader );\n\t\tthis._cache = {};\n\n\t}\n\n\t// Convert the given file information into a mesh by processing subobjects.\n\tasync processIntoMesh( info ) {\n\n\t\tconst loader = this.loader;\n\t\tconst parseCache = this.parseCache;\n\t\tconst faceMaterials = new Set();\n\n\t\t// Processes the part subobject information to load child parts and merge geometry onto part\n\t\t// piece object.\n\t\tconst processInfoSubobjects = async ( info, subobject = null ) => {\n\n\t\t\tconst subobjects = info.subobjects;\n\t\t\tconst promises = [];\n\n\t\t\t// Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n\t\t\t// group which lets instruction steps apply correctly.\n\t\t\tfor ( let i = 0, l = subobjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = subobjects[ i ];\n\t\t\t\tconst promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {\n\n\t\t\t\t\tconst subobjectInfo = parseCache.getData( subobject.fileName, false );\n\t\t\t\t\tif ( ! isPrimitiveType( subobjectInfo.type ) ) {\n\n\t\t\t\t\t\treturn this.loadModel( subobject.fileName ).catch( error => {\n\n\t\t\t\t\t\t\tconsole.warn( error );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );\n\n\t\t\t\t} );\n\n\t\t\t\tpromises.push( promise );\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.userData.category = info.category;\n\t\t\tgroup.userData.keywords = info.keywords;\n\t\t\tinfo.group = group;\n\n\t\t\tconst subobjectInfos = await Promise.all( promises );\n\t\t\tfor ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = info.subobjects[ i ];\n\t\t\t\tconst subobjectInfo = subobjectInfos[ i ];\n\n\t\t\t\tif ( subobjectInfo === null ) {\n\n\t\t\t\t\t// the subobject failed to load\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// if the subobject was loaded as a separate group then apply the parent scopes materials\n\t\t\t\tif ( subobjectInfo.isGroup ) {\n\n\t\t\t\t\tconst subobjectGroup = subobjectInfo;\n\t\t\t\t\tsubobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );\n\t\t\t\t\tsubobjectGroup.userData.startingConstructionStep = subobject.startingConstructionStep;\n\t\t\t\t\tsubobjectGroup.name = subobject.fileName;\n\n\t\t\t\t\tloader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );\n\n\t\t\t\t\tgroup.add( subobjectGroup );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// add the subobject group if it has children in case it has both children and primitives\n\t\t\t\tif ( subobjectInfo.group.children.length ) {\n\n\t\t\t\t\tgroup.add( subobjectInfo.group );\n\n\t\t\t\t}\n\n\t\t\t\t// transform the primitives into the local space of the parent piece and append them to\n\t\t\t\t// to the parent primitives list.\n\t\t\t\tconst parentLineSegments = info.lineSegments;\n\t\t\t\tconst parentConditionalSegments = info.conditionalSegments;\n\t\t\t\tconst parentFaces = info.faces;\n\n\t\t\t\tconst lineSegments = subobjectInfo.lineSegments;\n\t\t\t\tconst conditionalSegments = subobjectInfo.conditionalSegments;\n\n\t\t\t\tconst faces = subobjectInfo.faces;\n\t\t\t\tconst matrix = subobject.matrix;\n\t\t\t\tconst inverted = subobject.inverted;\n\t\t\t\tconst matrixScaleInverted = matrix.determinant() < 0;\n\t\t\t\tconst colorCode = subobject.colorCode;\n\n\t\t\t\tconst lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\t\t\t\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst ls = lineSegments[ i ];\n\t\t\t\t\tconst vertices = ls.vertices;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n\t\t\t\t\tls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );\n\n\t\t\t\t\tparentLineSegments.push( ls );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst os = conditionalSegments[ i ];\n\t\t\t\t\tconst vertices = os.vertices;\n\t\t\t\t\tconst controlPoints = os.controlPoints;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tos.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n\t\t\t\t\tos.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );\n\n\t\t\t\t\tparentConditionalSegments.push( os );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst tri = faces[ i ];\n\t\t\t\t\tconst vertices = tri.vertices;\n\t\t\t\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertices[ i ].applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n\t\t\t\t\ttri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );\n\t\t\t\t\tfaceMaterials.add( tri.colorCode );\n\n\t\t\t\t\t// If the scale of the object is negated then the triangle winding order\n\t\t\t\t\t// needs to be flipped.\n\t\t\t\t\tif ( matrixScaleInverted !== inverted ) {\n\n\t\t\t\t\t\tvertices.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparentFaces.push( tri );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.totalFaces += subobjectInfo.totalFaces;\n\n\t\t\t}\n\n\t\t\t// Apply the parent subobjects pass through material code to this object. This is done several times due\n\t\t\t// to material scoping.\n\t\t\tif ( subobject ) {\n\n\t\t\t\tloader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t};\n\n\t\t// Track material use to see if we need to use the normal smooth slow path for hard edges.\n\t\tfor ( let i = 0, l = info.faces; i < l; i ++ ) {\n\n\t\t\tfaceMaterials.add( info.faces[ i ].colorCode );\n\n\t\t}\n\n\t\tawait processInfoSubobjects( info );\n\n\t\tif ( loader.smoothNormals ) {\n\n\t\t\tconst checkSubSegments = faceMaterials.size > 1;\n\t\t\tgenerateFaceNormals( info.faces );\n\t\t\tsmoothNormals( info.faces, info.lineSegments, checkSubSegments );\n\n\t\t}\n\n\t\t// Add the primitive objects and metadata.\n\t\tconst group = info.group;\n\t\tif ( info.faces.length > 0 ) {\n\n\t\t\tgroup.add( createObject( info.faces, 3, false, info.totalFaces ) );\n\n\t\t}\n\n\t\tif ( info.lineSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( info.lineSegments, 2 ) );\n\n\t\t}\n\n\t\tif ( info.conditionalSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( info.conditionalSegments, 2, true ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t}\n\n\thasCachedModel( fileName ) {\n\n\t\treturn fileName !== null && fileName.toLowerCase() in this._cache;\n\n\t}\n\n\tasync getCachedModel( fileName ) {\n\n\t\tif ( fileName !== null && this.hasCachedModel( fileName ) ) {\n\n\t\t\tconst key = fileName.toLowerCase();\n\t\t\tconst group = await this._cache[ key ];\n\t\t\treturn group.clone();\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// Loads and parses the model with the given file name. Returns a cached copy if available.\n\tasync loadModel( fileName ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t// Return cached model if available.\n\t\t\treturn this.getCachedModel( fileName );\n\n\t\t} else {\n\n\t\t\t// Otherwise parse a new model.\n\t\t\t// Ensure the file data is loaded and pre parsed.\n\t\t\tawait parseCache.ensureDataLoaded( fileName );\n\n\t\t\tconst info = parseCache.getData( fileName );\n\t\t\tconst promise = this.processIntoMesh( info );\n\n\t\t\t// Now that the file has loaded it's possible that another part parse has been waiting in parallel\n\t\t\t// so check the cache again to see if it's been added since the last async operation so we don't\n\t\t\t// do unnecessary work.\n\t\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t\treturn this.getCachedModel( fileName );\n\n\t\t\t}\n\n\t\t\t// Cache object if it's a part so it can be reused later.\n\t\t\tif ( isPartType( info.type ) ) {\n\n\t\t\t\tthis._cache[ key ] = promise;\n\n\t\t\t}\n\n\t\t\t// return a copy\n\t\t\tconst group = await promise;\n\t\t\treturn group.clone();\n\n\t\t}\n\n\t}\n\n\t// parses the given model text into a renderable object. Returns cached copy if available.\n\tasync parseModel( text ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst info = parseCache.parse( text );\n\t\tif ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {\n\n\t\t\treturn this.getCachedModel( info.fileName );\n\n\t\t}\n\n\t\treturn this.processIntoMesh( info );\n\n\t}\n\n}\n\nfunction sortByMaterial( a, b ) {\n\n\tif ( a.colorCode === b.colorCode ) {\n\n\t\treturn 0;\n\n\t}\n\n\tif ( a.colorCode < b.colorCode ) {\n\n\t\treturn - 1;\n\n\t}\n\n\treturn 1;\n\n}\n\nfunction createObject( elements, elementSize, isConditionalSegments = false, totalElements = null ) {\n\n\t// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n\t// With per face / segment material, implemented with mesh groups and materials array\n\n\t// Sort the faces or line segments by color code to make later the mesh groups\n\telements.sort( sortByMaterial );\n\n\tif ( totalElements === null ) {\n\n\t\ttotalElements = elements.length;\n\n\t}\n\n\tconst positions = new Float32Array( elementSize * totalElements * 3 );\n\tconst normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;\n\tconst materials = [];\n\n\tconst quadArray = new Array( 6 );\n\tconst bufferGeometry = new BufferGeometry();\n\tlet prevMaterial = null;\n\tlet index0 = 0;\n\tlet numGroupVerts = 0;\n\tlet offset = 0;\n\n\tfor ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {\n\n\t\tconst elem = elements[ iElem ];\n\t\tlet vertices = elem.vertices;\n\t\tif ( vertices.length === 4 ) {\n\n\t\t\tquadArray[ 0 ] = vertices[ 0 ];\n\t\t\tquadArray[ 1 ] = vertices[ 1 ];\n\t\t\tquadArray[ 2 ] = vertices[ 2 ];\n\t\t\tquadArray[ 3 ] = vertices[ 0 ];\n\t\t\tquadArray[ 4 ] = vertices[ 2 ];\n\t\t\tquadArray[ 5 ] = vertices[ 3 ];\n\t\t\tvertices = quadArray;\n\n\t\t}\n\n\t\tfor ( let j = 0, l = vertices.length; j < l; j ++ ) {\n\n\t\t\tconst v = vertices[ j ];\n\t\t\tconst index = offset + j * 3;\n\t\t\tpositions[ index + 0 ] = v.x;\n\t\t\tpositions[ index + 1 ] = v.y;\n\t\t\tpositions[ index + 2 ] = v.z;\n\n\t\t}\n\n\t\t// create the normals array if this is a set of faces\n\t\tif ( elementSize === 3 ) {\n\n\t\t\tif ( ! elem.faceNormal ) {\n\n\t\t\t\tconst v0 = vertices[ 0 ];\n\t\t\t\tconst v1 = vertices[ 1 ];\n\t\t\t\tconst v2 = vertices[ 2 ];\n\t\t\t\t_tempVec0.subVectors( v1, v0 );\n\t\t\t\t_tempVec1.subVectors( v2, v1 );\n\t\t\t\telem.faceNormal = new Vector3()\n\t\t\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t\t\t.normalize();\n\n\t\t\t}\n\n\t\t\tlet elemNormals = elem.normals;\n\t\t\tif ( elemNormals.length === 4 ) {\n\n\t\t\t\tquadArray[ 0 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 1 ] = elemNormals[ 1 ];\n\t\t\t\tquadArray[ 2 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 3 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 4 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 5 ] = elemNormals[ 3 ];\n\t\t\t\telemNormals = quadArray;\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, l = elemNormals.length; j < l; j ++ ) {\n\n\t\t\t\t// use face normal if a vertex normal is not provided\n\t\t\t\tlet n = elem.faceNormal;\n\t\t\t\tif ( elemNormals[ j ] ) {\n\n\t\t\t\t\tn = elemNormals[ j ].norm;\n\n\t\t\t\t}\n\n\t\t\t\tconst index = offset + j * 3;\n\t\t\t\tnormals[ index + 0 ] = n.x;\n\t\t\t\tnormals[ index + 1 ] = n.y;\n\t\t\t\tnormals[ index + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( prevMaterial !== elem.colorCode ) {\n\n\t\t\tif ( prevMaterial !== null ) {\n\n\t\t\t\tbufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );\n\n\t\t\t}\n\n\t\t\tconst material = elem.material;\n\t\t\tif ( material !== null ) {\n\n\t\t\t\tif ( elementSize === 3 ) {\n\n\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t} else if ( elementSize === 2 ) {\n\n\t\t\t\t\tif ( material !== null ) {\n\n\t\t\t\t\t\tif ( isConditionalSegments ) {\n\n\t\t\t\t\t\t\tmaterials.push( material.userData.edgeMaterial.userData.conditionalEdgeMaterial );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterials.push( material.userData.edgeMaterial );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// If a material has not been made available yet then keep the color code string in the material array\n\t\t\t\t// to save the spot for the material once a parent scopes materials are being applied to the object.\n\t\t\t\tmaterials.push( elem.colorCode );\n\n\t\t\t}\n\n\t\t\tprevMaterial = elem.colorCode;\n\t\t\tindex0 = offset / 3;\n\t\t\tnumGroupVerts = vertices.length;\n\n\t\t} else {\n\n\t\t\tnumGroupVerts += vertices.length;\n\n\t\t}\n\n\t\toffset += 3 * vertices.length;\n\n\t}\n\n\tif ( numGroupVerts > 0 ) {\n\n\t\tbufferGeometry.addGroup( index0, Infinity, materials.length - 1 );\n\n\t}\n\n\tbufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tif ( normals !== null ) {\n\n\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tlet object3d = null;\n\n\tif ( elementSize === 2 ) {\n\n\t\tif ( isConditionalSegments ) {\n\n\t\t\tobject3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t} else {\n\n\t\t\tobject3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t}\n\n\t} else if ( elementSize === 3 ) {\n\n\t\tobject3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t}\n\n\tif ( isConditionalSegments ) {\n\n\t\tobject3d.isConditionalLine = true;\n\n\t\tconst controlArray0 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst controlArray1 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst directionArray = new Float32Array( elements.length * 3 * 2 );\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\tconst os = elements[ i ];\n\t\t\tconst vertices = os.vertices;\n\t\t\tconst controlPoints = os.controlPoints;\n\t\t\tconst c0 = controlPoints[ 0 ];\n\t\t\tconst c1 = controlPoints[ 1 ];\n\t\t\tconst v0 = vertices[ 0 ];\n\t\t\tconst v1 = vertices[ 1 ];\n\t\t\tconst index = i * 3 * 2;\n\t\t\tcontrolArray0[ index + 0 ] = c0.x;\n\t\t\tcontrolArray0[ index + 1 ] = c0.y;\n\t\t\tcontrolArray0[ index + 2 ] = c0.z;\n\t\t\tcontrolArray0[ index + 3 ] = c0.x;\n\t\t\tcontrolArray0[ index + 4 ] = c0.y;\n\t\t\tcontrolArray0[ index + 5 ] = c0.z;\n\n\t\t\tcontrolArray1[ index + 0 ] = c1.x;\n\t\t\tcontrolArray1[ index + 1 ] = c1.y;\n\t\t\tcontrolArray1[ index + 2 ] = c1.z;\n\t\t\tcontrolArray1[ index + 3 ] = c1.x;\n\t\t\tcontrolArray1[ index + 4 ] = c1.y;\n\t\t\tcontrolArray1[ index + 5 ] = c1.z;\n\n\t\t\tdirectionArray[ index + 0 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 1 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 2 ] = v1.z - v0.z;\n\t\t\tdirectionArray[ index + 3 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 4 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 5 ] = v1.z - v0.z;\n\n\t\t}\n\n\t\tbufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t}\n\n\treturn object3d;\n\n}\n\n//\n\nclass LDrawLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Array of THREE.Material\n\t\tthis.materials = [];\n\t\tthis.materialLibrary = {};\n\n\t\t// This also allows to handle the embedded text files (\"0 FILE\" lines)\n\t\tthis.partsCache = new LDrawPartsGeometryCache( this );\n\n\t\t// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\t\tthis.fileMap = {};\n\n\t\t// Initializes the materials library with default materials\n\t\tthis.setMaterials( [] );\n\n\t\t// If this flag is set to true the vertex normals will be smoothed.\n\t\tthis.smoothNormals = true;\n\n\t\t// The path to load parts from the LDraw parts library from.\n\t\tthis.partsLibraryPath = '';\n\n\t}\n\n\tsetPartsLibraryPath( path ) {\n\n\t\tthis.partsLibraryPath = path;\n\t\treturn this;\n\n\t}\n\n\tasync preloadMaterials( url ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await fileLoader.loadAsync( url );\n\t\tconst colorLineRegex = /^0 !COLOUR/;\n\t\tconst lines = text.split( /[\\n\\r]/g );\n\t\tconst materials = [];\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tconst line = lines[ i ];\n\t\t\tif ( colorLineRegex.test( line ) ) {\n\n\t\t\t\tconst directive = line.replace( colorLineRegex, '' );\n\t\t\t\tconst material = this.parseColorMetaDirective( new LineParser( directive ) );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setMaterials( materials );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\t\tfileLoader.load( url, text => {\n\n\t\t\tthis.partsCache\n\t\t\t\t.parseModel( text, this.materialLibrary )\n\t\t\t\t.then( group => {\n\n\t\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\t\tthis.computeConstructionSteps( group );\n\t\t\t\t\tonLoad( group );\n\n\t\t\t\t} )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text, onLoad ) {\n\n\t\tthis.partsCache\n\t\t\t.parseModel( text, this.materialLibrary )\n\t\t\t.then( group => {\n\n\t\t\t\tthis.computeConstructionSteps( group );\n\t\t\t\tonLoad( group );\n\n\t\t\t} );\n\n\t}\n\n\tsetMaterials( materials ) {\n\n\t\tthis.materialLibrary = {};\n\t\tthis.materials = [];\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tthis.addMaterial( materials[ i ] );\n\n\t\t}\n\n\t\t// Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );\n\n\t\treturn this;\n\n\t}\n\n\tsetFileMap( fileMap ) {\n\n\t\tthis.fileMap = fileMap;\n\n\t\treturn this;\n\n\t}\n\n\taddMaterial( material ) {\n\n\t\t// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n\t\tconst matLib = this.materialLibrary;\n\t\tif ( ! matLib[ material.userData.code ] ) {\n\n\t\t\tthis.materials.push( material );\n\t\t\tmatLib[ material.userData.code ] = material;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetMaterial( colorCode ) {\n\n\t\tif ( colorCode.startsWith( '0x2' ) ) {\n\n\t\t\t// Special 'direct' material value (RGB color)\n\t\t\tconst color = colorCode.substring( 3 );\n\n\t\t\treturn this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );\n\n\t\t}\n\n\t\treturn this.materialLibrary[ colorCode ] || null;\n\n\t}\n\n\t// Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n\t// in the material array if they need to be filled in.\n\tapplyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {\n\n\t\t// find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n\t\tconst loader = this;\n\t\tconst parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n\t\tgroup.traverse( c => {\n\n\t\t\tif ( c.isMesh || c.isLineSegments ) {\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = c.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( ! c.material[ i ].isMaterial ) {\n\n\t\t\t\t\t\t\tc.material[ i ] = getMaterial( c, c.material[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( ! c.material.isMaterial ) {\n\n\t\t\t\t\tc.material = getMaterial( c, c.material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\n\t\t// Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n\t\t// (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n\t\t// simply returned for the subsequent material application.\n\t\tfunction getMaterial( c, colorCode ) {\n\n\t\t\t// if our parent is a passthrough color code and we don't have the current material color available then\n\t\t\t// return early.\n\t\t\tif ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tconst forEdge = c.isLineSegments || c.isConditionalLine;\n\t\t\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\t\t\tif ( isPassthrough ) {\n\n\t\t\t\tcolorCode = parentColorCode;\n\n\t\t\t}\n\n\t\t\tlet material = null;\n\t\t\tif ( colorCode in materialHierarchy ) {\n\n\t\t\t\tmaterial = materialHierarchy[ colorCode ];\n\n\t\t\t} else if ( finalMaterialPass ) {\n\n\t\t\t\t// see if we can get the final material from from the \"getMaterial\" function which will attempt to\n\t\t\t\t// parse the \"direct\" colors\n\t\t\t\tmaterial = loader.getMaterial( colorCode );\n\t\t\t\tif ( material === null ) {\n\n\t\t\t\t\t// otherwise throw an error if this is final opportunity to set the material\n\t\t\t\t\tthrow new Error( `LDrawLoader: Material properties for code ${ colorCode } not available.` );\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\tmaterial = material.userData.edgeMaterial;\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tmaterial = material.userData.conditionalEdgeMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t}\n\n\tgetMainMaterial() {\n\n\t\treturn this.getMaterial( MAIN_COLOUR_CODE );\n\n\t}\n\n\tgetMainEdgeMaterial() {\n\n\t\tconst mainMat = this.getMainMaterial();\n\t\treturn mainMat && mainMat.userData ? mainMat.userData.edgeMaterial : null;\n\n\t}\n\n\tparseColorMetaDirective( lineParser ) {\n\n\t\t// Parses a color definition and returns a THREE.Material\n\n\t\tlet code = null;\n\n\t\t// Triangle and line colors\n\t\tlet color = 0xFF00FF;\n\t\tlet edgeColor = 0xFF00FF;\n\n\t\t// Transparency\n\t\tlet alpha = 1;\n\t\tlet isTransparent = false;\n\t\t// Self-illumination:\n\t\tlet luminance = 0;\n\n\t\tlet finishType = FINISH_TYPE_DEFAULT;\n\n\t\tlet edgeMaterial = null;\n\n\t\tconst name = lineParser.getToken();\n\t\tif ( ! name ) {\n\n\t\t\tthrow new Error( 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.' );\n\n\t\t}\n\n\t\t// Parse tag tokens and their parameters\n\t\tlet token = null;\n\t\twhile ( true ) {\n\n\t\t\ttoken = lineParser.getToken();\n\n\t\t\tif ( ! token ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( token.toUpperCase() ) {\n\n\t\t\t\tcase 'CODE':\n\n\t\t\t\t\tcode = lineParser.getToken();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'VALUE':\n\n\t\t\t\t\tcolor = lineParser.getToken();\n\t\t\t\t\tif ( color.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\tcolor = '#' + color.substring( 2 );\n\n\t\t\t\t\t} else if ( ! color.startsWith( '#' ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EDGE':\n\n\t\t\t\t\tedgeColor = lineParser.getToken();\n\t\t\t\t\tif ( edgeColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\tedgeColor = '#' + edgeColor.substring( 2 );\n\n\t\t\t\t\t} else if ( ! edgeColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t// Try to see if edge color is a color code\n\t\t\t\t\t\tedgeMaterial = this.getMaterial( edgeColor );\n\t\t\t\t\t\tif ( ! edgeMaterial ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Get the edge material for this triangle material\n\t\t\t\t\t\tedgeMaterial = edgeMaterial.userData.edgeMaterial;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ALPHA':\n\n\t\t\t\t\talpha = parseInt( lineParser.getToken() );\n\n\t\t\t\t\tif ( isNaN( alpha ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\talpha = Math.max( 0, Math.min( 1, alpha / 255 ) );\n\n\t\t\t\t\tif ( alpha < 1 ) {\n\n\t\t\t\t\t\tisTransparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LUMINANCE':\n\n\t\t\t\t\tluminance = parseInt( lineParser.getToken() );\n\n\t\t\t\t\tif ( isNaN( luminance ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tluminance = Math.max( 0, Math.min( 1, luminance / 255 ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'CHROME':\n\t\t\t\t\tfinishType = FINISH_TYPE_CHROME;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PEARLESCENT':\n\t\t\t\t\tfinishType = FINISH_TYPE_PEARLESCENT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RUBBER':\n\t\t\t\t\tfinishType = FINISH_TYPE_RUBBER;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'MATTE_METALLIC':\n\t\t\t\t\tfinishType = FINISH_TYPE_MATTE_METALLIC;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'METAL':\n\t\t\t\t\tfinishType = FINISH_TYPE_METAL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'MATERIAL':\n\t\t\t\t\t// Not implemented\n\t\t\t\t\tlineParser.setToEnd();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet material = null;\n\n\t\tswitch ( finishType ) {\n\n\t\t\tcase FINISH_TYPE_DEFAULT:\n\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.3, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_PEARLESCENT:\n\n\t\t\t\t// Try to imitate pearlescency by making the surface glossy\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.3, metalness: 0.25 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_CHROME:\n\n\t\t\t\t// Mirror finish surface\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0, metalness: 1 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_RUBBER:\n\n\t\t\t\t// Rubber finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.9, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_MATTE_METALLIC:\n\n\t\t\t\t// Brushed metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.8, metalness: 0.4 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_METAL:\n\n\t\t\t\t// Average metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.2, metalness: 0.85 } );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// Should not happen\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.transparent = isTransparent;\n\t\tmaterial.premultipliedAlpha = true;\n\t\tmaterial.opacity = alpha;\n\t\tmaterial.depthWrite = ! isTransparent;\n\t\tmaterial.color.convertSRGBToLinear();\n\n\t\tmaterial.polygonOffset = true;\n\t\tmaterial.polygonOffsetFactor = 1;\n\n\t\tif ( luminance !== 0 ) {\n\n\t\t\tmaterial.emissive.set( material.color ).multiplyScalar( luminance );\n\n\t\t}\n\n\t\tif ( ! edgeMaterial ) {\n\n\t\t\t// This is the material used for edges\n\t\t\tedgeMaterial = new LineBasicMaterial( {\n\t\t\t\tcolor: edgeColor,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\topacity: alpha,\n\t\t\t\tdepthWrite: ! isTransparent\n\t\t\t} );\n\t\t\tedgeMaterial.userData.code = code;\n\t\t\tedgeMaterial.name = name + ' - Edge';\n\t\t\tedgeMaterial.color.convertSRGBToLinear();\n\n\t\t\t// This is the material used for conditional edges\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial( {\n\n\t\t\t\tfog: true,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\tdepthWrite: ! isTransparent,\n\t\t\t\tcolor: edgeColor,\n\t\t\t\topacity: alpha,\n\n\t\t\t} );\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial.color.convertSRGBToLinear();\n\n\t\t}\n\n\t\tmaterial.userData.code = code;\n\t\tmaterial.name = name;\n\n\t\tmaterial.userData.edgeMaterial = edgeMaterial;\n\n\t\tthis.addMaterial( material );\n\n\t\treturn material;\n\n\t}\n\n\tcomputeConstructionSteps( model ) {\n\n\t\t// Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n\n\t\tlet stepNumber = 0;\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.isGroup ) {\n\n\t\t\t\tif ( c.userData.startingConstructionStep ) {\n\n\t\t\t\t\tstepNumber ++;\n\n\t\t\t\t}\n\n\t\t\t\tc.userData.constructionStep = stepNumber;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tmodel.userData.numConstructionSteps = stepNumber + 1;\n\n\t}\n\n}\n\nexport { LDrawLoader };\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tGroup,\n\tLineSegments,\n\tMatrix3,\n\tMesh\n} from 'three';\n\nimport { mergeBufferGeometries } from './BufferGeometryUtils.js';\n\nclass LDrawUtils {\n\n\tstatic mergeObject( object ) {\n\n\t\t// Merges geometries in object by materials and returns new object. Use on not indexed geometries.\n\t\t// The object buffers reference the old object ones.\n\t\t// Special treatment is done to the conditional lines generated by LDrawLoader.\n\n\t\tfunction extractGroup( geometry, group, elementSize, isConditionalLine ) {\n\n\t\t\t// Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)\n\n\t\t\tconst newGeometry = new BufferGeometry();\n\n\t\t\tconst originalPositions = geometry.getAttribute( 'position' ).array;\n\t\t\tconst originalNormals = elementSize === 3 ? geometry.getAttribute( 'normal' ).array : null;\n\n\t\t\tconst numVertsGroup = Math.min( group.count, Math.floor( originalPositions.length / 3 ) - group.start );\n\t\t\tconst vertStart = group.start * 3;\n\t\t\tconst vertEnd = ( group.start + numVertsGroup ) * 3;\n\n\t\t\tconst positions = originalPositions.subarray( vertStart, vertEnd );\n\t\t\tconst normals = originalNormals !== null ? originalNormals.subarray( vertStart, vertEnd ) : null;\n\n\t\t\tnewGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\t\tif ( normals !== null ) newGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( isConditionalLine ) {\n\n\t\t\t\tconst controlArray0 = geometry.getAttribute( 'control0' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst controlArray1 = geometry.getAttribute( 'control1' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst directionArray = geometry.getAttribute( 'direction' ).array.subarray( vertStart, vertEnd );\n\n\t\t\t\tnewGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t\t\t}\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t\tfunction addGeometry( mat, geometry, geometries ) {\n\n\t\t\tconst geoms = geometries[ mat.uuid ];\n\t\t\tif ( ! geoms ) {\n\n\t\t\t\tgeometries[ mat.uuid ] = {\n\t\t\t\t\tmat: mat,\n\t\t\t\t\tarr: [ geometry ]\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tgeoms.arr.push( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction permuteAttribute( attribute, elemSize ) {\n\n\t\t\t// Permutes first two vertices of each attribute element\n\n\t\t\tif ( ! attribute ) return;\n\n\t\t\tconst verts = attribute.array;\n\t\t\tconst numVerts = Math.floor( verts.length / 3 );\n\t\t\tlet offset = 0;\n\t\t\tfor ( let i = 0; i < numVerts; i ++ ) {\n\n\t\t\t\tconst x = verts[ offset ];\n\t\t\t\tconst y = verts[ offset + 1 ];\n\t\t\t\tconst z = verts[ offset + 2 ];\n\n\t\t\t\tverts[ offset ] = verts[ offset + 3 ];\n\t\t\t\tverts[ offset + 1 ] = verts[ offset + 4 ];\n\t\t\t\tverts[ offset + 2 ] = verts[ offset + 5 ];\n\n\t\t\t\tverts[ offset + 3 ] = x;\n\t\t\t\tverts[ offset + 4 ] = y;\n\t\t\t\tverts[ offset + 5 ] = z;\n\n\t\t\t\toffset += elemSize * 3;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Traverse the object hierarchy collecting geometries and transforming them to world space\n\n\t\tconst meshGeometries = {};\n\t\tconst linesGeometries = {};\n\t\tconst condLinesGeometries = {};\n\n\t\tobject.updateMatrixWorld( true );\n\t\tconst normalMatrix = new Matrix3();\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh | c.isLineSegments ) {\n\n\t\t\t\tconst elemSize = c.isMesh ? 3 : 2;\n\n\t\t\t\tconst geometry = c.geometry.clone();\n\t\t\t\tconst matrixIsInverted = c.matrixWorld.determinant() < 0;\n\t\t\t\tif ( matrixIsInverted ) {\n\n\t\t\t\t\tpermuteAttribute( geometry.attributes.position, elemSize );\n\t\t\t\t\tpermuteAttribute( geometry.attributes.normal, elemSize );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.applyMatrix4( c.matrixWorld );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tgeometry.attributes.control0.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.control1.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tnormalMatrix.getNormalMatrix( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.direction.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometries = c.isMesh ? meshGeometries : ( c.isConditionalLine ? condLinesGeometries : linesGeometries );\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( const groupIndex in geometry.groups ) {\n\n\t\t\t\t\t\tconst group = geometry.groups[ groupIndex ];\n\t\t\t\t\t\tconst mat = c.material[ group.materialIndex ];\n\t\t\t\t\t\tconst newGeometry = extractGroup( geometry, group, elemSize, c.isConditionalLine );\n\t\t\t\t\t\taddGeometry( mat, newGeometry, geometries );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddGeometry( c.material, geometry, geometries );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Create object with merged geometries\n\n\t\tconst mergedObject = new Group();\n\n\t\tconst meshMaterialsIds = Object.keys( meshGeometries );\n\t\tfor ( const i in meshMaterialsIds ) {\n\n\t\t\tconst meshGeometry = meshGeometries[ meshMaterialsIds[ i ] ];\n\t\t\tconst mergedGeometry = mergeBufferGeometries( meshGeometry.arr );\n\t\t\tmergedObject.add( new Mesh( mergedGeometry, meshGeometry.mat ) );\n\n\t\t}\n\n\t\tconst linesMaterialsIds = Object.keys( linesGeometries );\n\t\tfor ( const i in linesMaterialsIds ) {\n\n\t\t\tconst lineGeometry = linesGeometries[ linesMaterialsIds[ i ] ];\n\t\t\tconst mergedGeometry = mergeBufferGeometries( lineGeometry.arr );\n\t\t\tmergedObject.add( new LineSegments( mergedGeometry, lineGeometry.mat ) );\n\n\t\t}\n\n\t\tconst condLinesMaterialsIds = Object.keys( condLinesGeometries );\n\t\tfor ( const i in condLinesMaterialsIds ) {\n\n\t\t\tconst condLineGeometry = condLinesGeometries[ condLinesMaterialsIds[ i ] ];\n\t\t\tconst mergedGeometry = mergeBufferGeometries( condLineGeometry.arr );\n\t\t\tconst condLines = new LineSegments( mergedGeometry, condLineGeometry.mat );\n\t\t\tcondLines.isConditionalLine = true;\n\t\t\tmergedObject.add( condLines );\n\n\t\t}\n\n\t\tmergedObject.userData.constructionStep = 0;\n\t\tmergedObject.userData.numConstructionSteps = 1;\n\n\t\treturn mergedObject;\n\n\t}\n\n}\n\nexport { LDrawUtils };\n","import { Scene, WebGLRenderer, MeshBasicMaterial, Vector2, Mesh, PerspectiveCamera, sRGBEncoding } from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { SAH } from 'three-mesh-bvh';\nimport { GenerateMeshBVHWorker } from 'three-mesh-bvh/src/workers/GenerateMeshBVHWorker.js';\nimport { PathTracingRenderer } from '../core/PathTracingRenderer.js';\nimport { mergeMeshes } from '../utils/GeometryPreparationUtils.js';\nimport { LambertPathTracingMaterial } from '../materials/LambertPathTracingMaterial.js';\nimport { MaterialReducer } from '../core/MaterialReducer.js';\n\nexport class PathTracingViewer {\n\n\tget domElement() {\n\n\t\treturn this._container;\n\n\t}\n\n\tconstructor() {\n\n\t\tthis.scene = new Scene();\n\t\tthis.camera = new PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.025, 500 );\n\t\tthis.camera.position.set( 1, 0.5, 1 );\n\n\t\tthis.renderer = new WebGLRenderer( { antialias: true } );\n\t\tthis.fsQuad = new FullScreenQuad( new MeshBasicMaterial( { transparent: true } ) );\n\t\tthis.ptRenderer = new PathTracingRenderer( this.renderer );\n\t\tthis.ptModel = null;\n\t\tthis.ptMaterials = null;\n\t\tthis.ptTextures = null;\n\t\tthis.model = null;\n\t\tthis.bvhGenerator = new GenerateMeshBVHWorker();\n\t\tthis.onRender = null;\n\t\tthis.enablePathTracing = true;\n\t\tthis.pausePathTracing = false;\n\t\tthis.samplesPerFrame = 1;\n\t\tthis._scale = 1;\n\t\tthis._nextObject = null;\n\t\tthis._needsSizeUpdate = false;\n\t\tthis._newSize = new Vector2();\n\t\tthis._resizeObserver = new ResizeObserver( entries => {\n\n\t\t\tconst { contentRect } = entries[ 0 ];\n\t\t\tthis._newSize.set( contentRect.width, contentRect.height );\n\t\t\tthis._needsSizeUpdate = true;\n\n\t\t} );\n\n\t\tconst container = document.createElement( 'div' );\n\t\tcontainer.style.overflow = 'hidden';\n\t\tcontainer.appendChild( this.renderer.domElement );\n\t\tthis._container = container;\n\n\t\tthis.ptRenderer.camera = this.camera;\n\t\tthis.ptRenderer.material = new LambertPathTracingMaterial( { transparent: true, depthWrite: false } );\n\t\tthis.renderer.outputEncoding = sRGBEncoding;\n\t\tthis._resizeObserver.observe( container );\n\n\t}\n\n\t_updateSize() {\n\n\t\tconst dpr = window.devicePixelRatio;\n\t\tconst scale = this._scale;\n\t\tconst size = this._newSize;\n\t\tthis.renderer.setPixelRatio( dpr );\n\n\t\tthis.renderer.domElement.style.aspectRatio = `${ size.width } / ${ size.height }`;\n\t\tthis.renderer.domElement.style.width = `100%`;\n\t\tthis.renderer.setSize( scale * size.width, scale * size.height, false );\n\t\tthis.ptRenderer.target.setSize( size.width * scale * dpr, size.height * scale * dpr );\n\t\tthis.camera.aspect = size.width / size.height;\n\t\tthis.camera.updateProjectionMatrix();\n\t\tthis._needsSizeUpdate = false;\n\n\t}\n\n\tsetScale( scale ) {\n\n\t\tthis._scale = scale;\n\t\tthis._needsSizeUpdate = true;\n\n\t}\n\n\tsetModel( object, bvhOptions = {} ) {\n\n\t\tif ( this.bvhGenerator.running ) {\n\n\t\t\tthis._nextObject = object;\n\t\t\treturn;\n\n\t\t}\n\n\t\tobject.updateMatrixWorld( true );\n\n\t\tconst materialReducer = new MaterialReducer();\n\t\tmaterialReducer.process( object );\n\n\t\tconst meshes = [];\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst { geometry, materials, textures } = mergeMeshes( meshes, { attributes: [ 'position', 'normal', 'tangent', 'uv' ] } );\n\t\treturn this\n\t\t\t.bvhGenerator\n\t\t\t.generate( geometry, { strategy: SAH, maxLeafTris: 1, ...bvhOptions } )\n\t\t\t.then( bvh => {\n\n\t\t\t\tif ( this._nextObject ) {\n\n\t\t\t\t\tthis.setModel( this._nextObject );\n\t\t\t\t\tthis._nextObject = null;\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.model ) {\n\n\t\t\t\t\tthis.scene.remove( this.model );\n\t\t\t\t\tthis.ptTextures.forEach( tex => tex.dispose() );\n\t\t\t\t\tthis.ptMaterials.forEach( mat => mat.dispose() );\n\n\t\t\t\t}\n\n\t\t\t\tconst mesh = new Mesh( geometry );\n\t\t\t\tthis.scene.add( object );\n\t\t\t\tthis.ptModel = mesh;\n\t\t\t\tthis.ptMaterials = materials;\n\t\t\t\tthis.ptTextures = textures;\n\t\t\t\tthis.model = object;\n\n\t\t\t\tconst { ptRenderer } = this;\n\t\t\t\tconst { material } = ptRenderer;\n\n\t\t\t\t// dispose of textures because they cannot be updated in later version of three.js\n\t\t\t\tmaterial.bvh.dispose();\n\t\t\t\tmaterial.normalAttribute.dispose();\n\t\t\t\tmaterial.tangentAttribute.dispose();\n\t\t\t\tmaterial.uvAttribute.dispose();\n\t\t\t\tmaterial.materialIndexAttribute.dispose();\n\t\t\t\tmaterial.textures.dispose();\n\n\t\t\t\tmaterial.bvh.updateFrom( bvh );\n\t\t\t\tmaterial.normalAttribute.updateFrom( geometry.attributes.normal );\n\t\t\t\tmaterial.tangentAttribute.updateFrom( geometry.attributes.tangent );\n\t\t\t\tmaterial.uvAttribute.updateFrom( geometry.attributes.uv );\n\t\t\t\tmaterial.materialIndexAttribute.updateFrom( geometry.attributes.materialIndex );\n\t\t\t\tmaterial.textures.setTextures( this.renderer, 2048, 2048, textures );\n\t\t\t\tmaterial.materials.updateFrom( materials, textures );\n\t\t\t\tmaterial.setDefine( 'MATERIAL_LENGTH', materials.length );\n\t\t\t\tptRenderer.reset();\n\n\t\t\t} );\n\n\t}\n\n\tsetEnvironment( envMap ) {\n\n\t\tthis.scene.environment = envMap;\n\n\t}\n\n\tinit() {\n\n\t\tconst { ptRenderer, renderer, fsQuad, camera } = this;\n\n\t\tconst controls = new OrbitControls( camera, renderer.domElement );\n\t\tlet delaySamples = 0;\n\t\tcontrols.addEventListener( 'change', () => {\n\n\t\t\tconst tiles = this.ptRenderer.tiles;\n\t\t\tif ( tiles.x * tiles.y !== 1 ) {\n\n\t\t\t\tdelaySamples = 1;\n\n\t\t\t}\n\n\t\t\tptRenderer.reset();\n\n\t\t} );\n\n\t\trenderer.setAnimationLoop( () => {\n\n\t\t\tif ( this.pausePathTracing ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this._needsSizeUpdate ) {\n\n\t\t\t\tthis._updateSize();\n\t\t\t\tthis.ptRenderer.reset();\n\n\t\t\t}\n\n\t\t\tif ( this.model ) {\n\n\t\t\t\tif ( this.enablePathTracing && delaySamples === 0 ) {\n\n\t\t\t\t\tcamera.updateMatrixWorld();\n\n\t\t\t\t\tfor ( let i = 0, l = this.samplesPerFrame; i < l; i ++ ) {\n\n\t\t\t\t\t\tptRenderer.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ptRenderer.samples < 1 ) {\n\n\t\t\t\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.autoClear = false;\n\t\t\t\t\tfsQuad.material.map = ptRenderer.target.texture;\n\t\t\t\t\tfsQuad.render( renderer );\n\t\t\t\t\trenderer.autoClear = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( delaySamples > 0 ) {\n\n\t\t\t\t\t\tdelaySamples --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderer.clear();\n\n\t\t\t}\n\n\t\t\tif ( this.onRender ) {\n\n\t\t\t\tthis.onRender();\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","import { ShaderMaterial, Matrix4, Color } from 'three';\nimport {\n\tMeshBVHUniformStruct, FloatVertexAttributeTexture, UIntVertexAttributeTexture,\n\tshaderStructs, shaderIntersectFunction,\n} from 'three-mesh-bvh';\nimport { shaderMaterialStructs, pathTracingHelpers } from '../shader/shaderStructs.js';\nimport { MaterialStructArrayUniform } from '../uniforms/MaterialStructArrayUniform.js';\nimport { RenderTarget2DArray } from '../uniforms/RenderTarget2DArray.js';\n\nexport class LambertPathTracingMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\t\t\t\tBOUNCES: 3,\n\t\t\t\tMATERIAL_LENGTH: 0,\n\t\t\t\tUSE_ENVMAP: 1,\n\t\t\t\tGRADIENT_BG: 0,\n\t\t\t\tDISPLAY_FLOOR: 1,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\n\t\t\t\tnormalAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\ttangentAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\tuvAttribute: { value: new FloatVertexAttributeTexture() },\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\n\t\t\t\tmaterials: { value: new MaterialStructArrayUniform() },\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\n\t\t\t\tenvironmentBlur: { value: 0.2 },\n\t\t\t\tenvironmentIntensity: { value: 2.0 },\n\t\t\t\tenvironmentMap: { value: null },\n\t\t\t\tseed: { value: 0 },\n\t\t\t\topacity: { value: 1 },\n\n\t\t\t\tgradientTop: { value: new Color( 0xbfd8ff ) },\n\t\t\t\tgradientBottom: { value: new Color( 0xffffff ) },\n\n\t\t\t\tbgGradientTop: { value: new Color( 0x111111 ) },\n\t\t\t\tbgGradientBottom: { value: new Color( 0x000000 ) },\n\n\t\t\t\tfloorHeight: { value: 0.0 },\n\t\t\t\tfloorColor: { value: new Color( 0x080808 ) },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n                varying vec2 vUv;\n                void main() {\n\n                    vec4 mvPosition = vec4( position, 1.0 );\n                    mvPosition = modelViewMatrix * mvPosition;\n                    gl_Position = projectionMatrix * mvPosition;\n\n                    vUv = uv;\n\n                }\n\n            `,\n\n\t\t\tfragmentShader: /* glsl */`\n                #define RAY_OFFSET 1e-5\n\t\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n                precision highp isampler2D;\n                precision highp usampler2D;\n                precision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n                #include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n                ${ shaderStructs }\n                ${ shaderIntersectFunction }\n\t\t\t\t${ shaderMaterialStructs }\n\t\t\t\t${ pathTracingHelpers }\n\n\t\t\t\t#if USE_ENVMAP\n\n\t\t\t\tuniform float environmentBlur;\n                uniform sampler2D environmentMap;\n\n\t\t\t\t#else\n\n                uniform vec3 gradientTop;\n                uniform vec3 gradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if GRADIENT_BG\n\n\t\t\t\tuniform vec3 bgGradientTop;\n                uniform vec3 bgGradientBottom;\n\n\t\t\t\t#endif\n\n\t\t\t\t#if DISPLAY_FLOOR\n\n\t\t\t\tuniform vec3 floorColor;\n\t\t\t\tuniform float floorHeight;\n\n\t\t\t\t#endif\n\n                uniform mat4 cameraWorldMatrix;\n                uniform mat4 invProjectionMatrix;\n                uniform sampler2D normalAttribute;\n                uniform sampler2D tangentAttribute;\n                uniform sampler2D uvAttribute;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n                uniform BVH bvh;\n                uniform float environmentIntensity;\n                uniform int seed;\n                uniform float opacity;\n\t\t\t\tuniform Material materials[ MATERIAL_LENGTH ];\n\t\t\t\tuniform sampler2DArray textures;\n                varying vec2 vUv;\n\n                void main() {\n\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\n                    // get [-1, 1] normalized device coordinates\n                    vec2 ndc = 2.0 * vUv - vec2( 1.0 );\n                    vec3 rayOrigin, rayDirection;\n                    ndcToCameraRay( ndc, cameraWorldMatrix, invProjectionMatrix, rayOrigin, rayDirection );\n\n                    // Lambertian render\n                    gl_FragColor = vec4( 0.0 );\n\n                    vec3 throughputColor = vec3( 1.0 );\n\n                    // hit results\n                    uvec4 faceIndices = uvec4( 0u );\n                    vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n                    vec3 barycoord = vec3( 0.0 );\n                    float side = 1.0;\n                    float dist = 0.0;\n\t\t\t\t\tint i;\n                    for ( i = 0; i < BOUNCES; i ++ ) {\n\n                        if ( ! bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist ) ) {\n\n\t\t\t\t\t\t\t#if DISPLAY_FLOOR\n\n\t\t\t\t\t\t\t// display a radial gradient floor\n\t\t\t\t\t\t\tfloat distToFloor = ( floorHeight - rayOrigin.y ) / rayDirection.y;\n\t\t\t\t\t\t\tvec3 floorNormal = vec3( 0.0, 1.0, 0.0 );\n\t\t\t\t\t\t\tvec3 floorHitPoint = rayOrigin + rayDirection * distToFloor + floorNormal * RAY_OFFSET;\n\t\t\t\t\t\t\tfloat centerDist = length( floorHitPoint.xz );\n\t\t\t\t\t\t\tfloat alpha = pow( saturate( 1.25 - centerDist ), 2.0 );\n\t\t\t\t\t\t\tif ( distToFloor > dist && dot( floorNormal, rayDirection ) < 0.0 && alpha > rand() ) {\n\n\t\t\t\t\t\t\t\trayOrigin = floorHitPoint;\n\t\t\t\t\t\t\t\trayDirection = getHemisphereSample( floorNormal, rand2() );\n\t\t\t\t\t\t\t\tthroughputColor *= floorColor / PI;\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t#if GRADIENT_BG\n\n\t\t\t\t\t\t\tif ( i == 0 ) {\n\n\t\t\t\t\t\t\t\trayDirection = normalize( rayDirection );\n\t\t\t\t\t\t\t\tfloat value = ( rayDirection.y + 1.0 ) / 2.0;\n\n\t\t\t\t\t\t\t\tvalue = pow( value, 2.0 );\n\n\t\t\t\t\t\t\t\tgl_FragColor = vec4( mix( bgGradientBottom, bgGradientTop, value ), 1.0 );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t#if USE_ENVMAP\n\n                            vec3 skyColor = textureCubeUV( environmentMap, rayDirection, environmentBlur ).rgb;\n\n\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\trayDirection = normalize( rayDirection );\n\t\t\t\t\t\t\tfloat value = ( rayDirection.y + 1.0 ) / 2.0;\n\t\t\t\t\t\t\tvec3 skyColor = mix( gradientBottom, gradientTop, value );\n\n\t\t\t\t\t\t\t#endif\n\n                            gl_FragColor += vec4( skyColor * throughputColor * environmentIntensity, 1.0 );\n\n                            break;\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = materials[ materialIndex ];\n\n\t\t\t\t\t\tif ( material.opacity < rand() ) {\n\n\t\t\t\t\t\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\t\t\t\t\t\trayOrigin += rayDirection * dist - faceNormal * RAY_OFFSET;\n\t\t\t\t\t\t\tthroughputColor *= mix( vec3( 1.0 ), material.color, 0.5 * material.opacity );\n\n\t\t\t\t\t\t\ti --;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n                        // fetch the interpolated smooth normal\n                        vec3 normal = normalize( textureSampleBarycoord(\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t).xyz );\n\n\t\t\t\t\t\tvec2 uv = textureSampleBarycoord( uvAttribute, barycoord, faceIndices.xyz ).xy;\n\n\t\t\t\t\t\t// emission\n\t\t\t\t\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\t\t\t\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\t\t\t\t\temission *= texture2D( textures, vec3( uv, material.emissiveMap ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl_FragColor.rgb += throughputColor * emission * max( side, 0.0 );\n\n\t\t\t\t\t\t// 1 / PI attenuation for physically correct lambert model\n                        // https://www.rorydriscoll.com/2009/01/25/energy-conservation-in-games/\n                        throughputColor *= 1.0 / PI;\n\n\t\t\t\t\t\t// albedo\n\t\t\t\t\t\tthroughputColor *= material.color;\n\t\t\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\t\t\tthroughputColor *= texture2D( textures, vec3( uv, material.map ) ).xyz;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normal\n\t\t\t\t\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\t\t\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\t\t\t\t\ttangentAttribute,\n\t\t\t\t\t\t\t\tbarycoord,\n\t\t\t\t\t\t\t\tfaceIndices.xyz\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t\t\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\t\t\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\t\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\t\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\t\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\t\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uv, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\t\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormal *= side;\n\n                        // adjust the hit point by the surface normal by a factor of some offset and the\n                        // maximum component-wise value of the current point to accommodate floating point\n                        // error as values increase.\n                        vec3 point = rayOrigin + rayDirection * dist;\n                        vec3 absPoint = abs( point );\n                        float maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n                        rayOrigin = point + faceNormal * ( maxPoint + 1.0 ) * RAY_OFFSET;\n                        rayDirection = getHemisphereSample( normal, rand2() );\n\n\t\t\t\t\t\t// if the surface normal is skewed such that the outgoing vector can wind up underneath\n\t\t\t\t\t\t// the triangle surface then just consider it absorbed.\n\t\t\t\t\t\tif ( dot( rayDirection, faceNormal ) < 0.0 ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\n                    }\n\n\t\t\t\t\t// gl_FragColor.rgb = mix( gl_FragColor.rgb / 2.0, gl_FragColor.rgb, clamp( float( i ), 0.0, 1.0 ) );\n\t\t\t\t\t// gl_FragColor.rgb = mix( textureCubeUV( environmentMap, rayDirection, 0.0 ).rgb, gl_FragColor.rgb, clamp( float( i ), 0.0, 1.0 ) );\n                    gl_FragColor.a = opacity;\n\n                }\n\n            `\n\n\t\t} );\n\n\t\tfor ( const key in this.uniforms ) {\n\n\t\t\tObject.defineProperty( this, key, {\n\n\t\t\t\tget() {\n\n\t\t\t\t\treturn this.uniforms[ key ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset( v ) {\n\n\t\t\t\t\tthis.uniforms[ key ].value = v;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetDefine( name, value = undefined ) {\n\n\t\tif ( value === undefined || value === null ) {\n\n\t\t\tif ( name in this.defines ) {\n\n\t\t\t\tdelete this.defines[ name ];\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.defines[ name ] !== value ) {\n\n\t\t\t\tthis.defines[ name ] = value;\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","// https://github.com/gkjohnson/webxr-sandbox/blob/main/skinned-mesh-batching/src/MaterialReducer.js\n\nfunction isTypedArray( arr ) {\n\n\treturn arr.buffer instanceof ArrayBuffer && 'BYTES_PER_ELEMENT' in arr;\n\n}\n\nexport class MaterialReducer {\n\n\tconstructor() {\n\n\t\tconst ignoreKeys = new Set();\n\t\tignoreKeys.add( 'uuid' );\n\n\t\tthis.ignoreKeys = ignoreKeys;\n\t\tthis.shareTextures = true;\n\t\tthis.textures = [];\n\t\tthis.materials = [];\n\n\t}\n\n\tareEqual( objectA, objectB ) {\n\n\t\tconst keySet = new Set();\n\t\tconst traverseSet = new Set();\n\t\tconst ignoreKeys = this.ignoreKeys;\n\n\t\tconst traverse = ( a, b ) => {\n\n\t\t\tif ( a === b ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif ( a && b && a instanceof Object && b instanceof Object ) {\n\n\t\t\t\tif ( traverseSet.has( a ) || traverseSet.has( b ) ) {\n\n\t\t\t\t\tthrow new Error( 'MaterialReducer: Material is recursive.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsElement = a instanceof Element;\n\t\t\t\tconst bIsElement = b instanceof Element;\n\t\t\t\tif ( aIsElement || bIsElement ) {\n\n\t\t\t\t\tif ( aIsElement !== bIsElement || ! ( a instanceof Image ) || ! ( b instanceof Image ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn a.src === b.src;\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsImageBitmap = a instanceof ImageBitmap;\n\t\t\t\tconst bIsImageBitmap = b instanceof ImageBitmap;\n\t\t\t\tif ( aIsImageBitmap || bIsImageBitmap ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( a.equals ) {\n\n\t\t\t\t\treturn a.equals( b );\n\n\t\t\t\t}\n\n\t\t\t\tconst aIsTypedArray = isTypedArray( a );\n\t\t\t\tconst bIsTypedArray = isTypedArray( b );\n\t\t\t\tif ( aIsTypedArray || bIsTypedArray ) {\n\n\t\t\t\t\tif ( aIsTypedArray !== bIsTypedArray || a.constructor !== b.constructor || a.length !== b.length ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.add( a );\n\t\t\t\ttraverseSet.add( b );\n\n\t\t\t\tkeySet.clear();\n\t\t\t\tfor ( const key in a ) {\n\n\t\t\t\t\tif ( ! a.hasOwnProperty( key ) || a[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const key in b ) {\n\n\t\t\t\t\tif ( ! b.hasOwnProperty( key ) || b[ key ] instanceof Function || ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tkeySet.add( key );\n\n\t\t\t\t}\n\n\t\t\t\tconst keys = Array.from( keySet.values() );\n\t\t\t\tlet result = true;\n\t\t\t\tfor ( const i in keys ) {\n\n\t\t\t\t\tconst key = keys[ i ];\n\t\t\t\t\tif ( ignoreKeys.has( key ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = traverse( a[ key ], b[ key ] );\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttraverseSet.delete( a );\n\t\t\t\ttraverseSet.delete( b );\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t\treturn traverse( objectA, objectB );\n\n\t}\n\n\tprocess( object ) {\n\n\t\tconst { textures, materials } = this;\n\t\tlet replaced = 0;\n\n\t\tconst processMaterial = material => {\n\n\t\t\t// Check if another material matches this one\n\t\t\tlet foundMaterial = null;\n\t\t\tfor ( const i in materials ) {\n\n\t\t\t\tconst otherMaterial = materials[ i ];\n\t\t\t\tif ( this.areEqual( material, otherMaterial ) ) {\n\n\t\t\t\t\tfoundMaterial = otherMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( foundMaterial ) {\n\n\t\t\t\treplaced ++;\n\t\t\t\treturn foundMaterial;\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( material );\n\n\t\t\t\tif ( this.shareTextures ) {\n\n\t\t\t\t\t// See if there's another texture that matches the ones on this material\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tif ( ! material.hasOwnProperty( key ) ) continue;\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture && value.image instanceof Image ) {\n\n\t\t\t\t\t\t\tlet foundTexture = null;\n\t\t\t\t\t\t\tfor ( const i in textures ) {\n\n\t\t\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\t\t\tif ( this.areEqual( texture, value ) ) {\n\n\t\t\t\t\t\t\t\t\tfoundTexture = texture;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( foundTexture ) {\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = foundTexture;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttextures.push( value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t};\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh && c.material ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\tmaterial[ i ] = processMaterial( material[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = processMaterial( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn { replaced, retained: materials.length };\n\n\t}\n\n}\n","var Stats = function () {\n\n\tvar mode = 0;\n\n\tvar container = document.createElement( 'div' );\n\tcontainer.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';\n\tcontainer.addEventListener( 'click', function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tshowPanel( ++ mode % container.children.length );\n\n\t}, false );\n\n\t//\n\n\tfunction addPanel( panel ) {\n\n\t\tcontainer.appendChild( panel.dom );\n\t\treturn panel;\n\n\t}\n\n\tfunction showPanel( id ) {\n\n\t\tfor ( var i = 0; i < container.children.length; i ++ ) {\n\n\t\t\tcontainer.children[ i ].style.display = i === id ? 'block' : 'none';\n\n\t\t}\n\n\t\tmode = id;\n\n\t}\n\n\t//\n\n\tvar beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;\n\n\tvar fpsPanel = addPanel( new Stats.Panel( 'FPS', '#0ff', '#002' ) );\n\tvar msPanel = addPanel( new Stats.Panel( 'MS', '#0f0', '#020' ) );\n\n\tif ( self.performance && self.performance.memory ) {\n\n\t\tvar memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );\n\n\t}\n\n\tshowPanel( 0 );\n\n\treturn {\n\n\t\tREVISION: 16,\n\n\t\tdom: container,\n\n\t\taddPanel: addPanel,\n\t\tshowPanel: showPanel,\n\n\t\tbegin: function () {\n\n\t\t\tbeginTime = ( performance || Date ).now();\n\n\t\t},\n\n\t\tend: function () {\n\n\t\t\tframes ++;\n\n\t\t\tvar time = ( performance || Date ).now();\n\n\t\t\tmsPanel.update( time - beginTime, 200 );\n\n\t\t\tif ( time >= prevTime + 1000 ) {\n\n\t\t\t\tfpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );\n\n\t\t\t\tprevTime = time;\n\t\t\t\tframes = 0;\n\n\t\t\t\tif ( memPanel ) {\n\n\t\t\t\t\tvar memory = performance.memory;\n\t\t\t\t\tmemPanel.update( memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn time;\n\n\t\t},\n\n\t\tupdate: function () {\n\n\t\t\tbeginTime = this.end();\n\n\t\t},\n\n\t\t// Backwards Compatibility\n\n\t\tdomElement: container,\n\t\tsetMode: showPanel\n\n\t};\n\n};\n\nStats.Panel = function ( name, fg, bg ) {\n\n\tvar min = Infinity, max = 0, round = Math.round;\n\tvar PR = round( window.devicePixelRatio || 1 );\n\n\tvar WIDTH = 80 * PR, HEIGHT = 48 * PR,\n\t\tTEXT_X = 3 * PR, TEXT_Y = 2 * PR,\n\t\tGRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,\n\t\tGRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;\n\n\tvar canvas = document.createElement( 'canvas' );\n\tcanvas.width = WIDTH;\n\tcanvas.height = HEIGHT;\n\tcanvas.style.cssText = 'width:80px;height:48px';\n\n\tvar context = canvas.getContext( '2d' );\n\tcontext.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';\n\tcontext.textBaseline = 'top';\n\n\tcontext.fillStyle = bg;\n\tcontext.fillRect( 0, 0, WIDTH, HEIGHT );\n\n\tcontext.fillStyle = fg;\n\tcontext.fillText( name, TEXT_X, TEXT_Y );\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\tcontext.fillStyle = bg;\n\tcontext.globalAlpha = 0.9;\n\tcontext.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );\n\n\treturn {\n\n\t\tdom: canvas,\n\n\t\tupdate: function ( value, maxValue ) {\n\n\t\t\tmin = Math.min( min, value );\n\t\t\tmax = Math.max( max, value );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 1;\n\t\t\tcontext.fillRect( 0, 0, WIDTH, GRAPH_Y );\n\t\t\tcontext.fillStyle = fg;\n\t\t\tcontext.fillText( round( value ) + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );\n\n\t\t\tcontext.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );\n\n\t\t\tcontext.fillStyle = bg;\n\t\t\tcontext.globalAlpha = 0.9;\n\t\t\tcontext.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );\n\n\t\t}\n\n\t};\n\n};\n\nexport default Stats;\n"],"names":["$ilwiq","parcelRequire","$90a1bf3572dc4d5f$var$_tempVec0","Vector3","$90a1bf3572dc4d5f$var$_tempVec1","$90a1bf3572dc4d5f$var$LDrawConditionalLineMaterial","ShaderMaterial","constructor","parameters","super","uniforms","UniformsUtils","merge","UniformsLib","fog","diffuse","value","Color","opacity","vertexShader","fragmentShader","Object","defineProperties","this","get","set","color","setValues","isLDrawConditionalLineMaterial","$90a1bf3572dc4d5f$var$ConditionalLineSegments","LineSegments","geometry","material","isConditionalLine","$90a1bf3572dc4d5f$var$_ray","Ray","$90a1bf3572dc4d5f$var$isPartType","type","$90a1bf3572dc4d5f$var$LineParser","line","lineNumber","lineLength","length","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getVector","parseFloat","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","$90a1bf3572dc4d5f$var$LDrawParsedCache","loader","_cache","cloneResult","original","result","faces","map","face","colorCode","vertices","v","clone","normals","faceNormal","conditionalSegments","controlPoints","lineSegments","category","keywords","subobjects","totalFaces","startingConstructionStep","materials","group","async","fileName","triedLowerCase","locationState","subobjectURL","lastIndexOf","toLowerCase","fileLoader","FileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loadAsync","Error","parse","text","getLocalMaterial","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","lineType","segment","ccw","doubleSided","v0","v1","v2","v3","c0","c1","meta","parseColorMetaDirective","userData","code","console","warn","newKeywords","forEach","keyword","push","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","Matrix4","fileMap","inverted","getData","key","Promise","fetchData","then","info","$90a1bf3572dc4d5f$var$getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","$90a1bf3572dc4d5f$var$LDrawPartsGeometryCache","parseCache","info1","faceMaterials","Set","processInfoSubobjects","subobject","promises","i","l","promise","ensureDataLoaded","subobjectInfo","test","loadModel","catch","error","Group","subobjectInfos","all","i3","l3","isGroup","subobjectGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","add","children","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","determinant","lineColorCode","ls","applyMatrix4","i5","l5","os","i6","l6","tri","reverse","i4","l4","smoothNormals","checkSubSegments","size","subVectors","crossVectors","normalize","$90a1bf3572dc4d5f$var$generateFaceNormals","hashMultiplier","hashVertex","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","hardEdgeRays","Map","halfEdgeList","rh1","has","rh2","distances","d0","d1","i1","l1","vertCount","i2","index","next","hash","rayHash","found","halfEdge","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","l2","$90a1bf3572dc4d5f$var$smoothNormals","group1","$90a1bf3572dc4d5f$var$createObject","hasCachedModel","getCachedModel","processIntoMesh","$90a1bf3572dc4d5f$var$sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","BufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","conditionalEdgeMaterial","Infinity","setAttribute","BufferAttribute","object3d","Mesh","controlArray0","controlArray1","directionArray","$90a1bf3572dc4d5f$export$12d9a9ad6192c950","Loader","materialLibrary","partsCache","setMaterials","setPartsLibraryPath","path","url","colorLineRegex","directive","load","onLoad","onProgress","onError","parseModel","computeConstructionSteps","addMaterial","setFileMap","matLib","getMaterial","finalMaterialPass","parentIsPassthrough","c","isLineSegments","traverse","isMesh","isArray","isMaterial","getMainMaterial","getMainEdgeMaterial","mainMat","lineParser","edgeColor","alpha","isTransparent","luminance","finishType","toUpperCase","parseInt","isNaN","max","min","MeshStandardMaterial","roughness","metalness","transparent","premultipliedAlpha","depthWrite","convertSRGBToLinear","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","LineBasicMaterial","model","stepNumber","constructionStep","numConstructionSteps","$ea7f392dc4b06523$export$7516d43a05de11c0","defines","BOUNCES","MATERIAL_LENGTH","USE_ENVMAP","GRADIENT_BG","DISPLAY_FLOOR","bvh","$8Zfx2","MeshBVHUniformStruct","normalAttribute","FloatVertexAttributeTexture","tangentAttribute","uvAttribute","materialIndexAttribute","UIntVertexAttributeTexture","$dJ2FF","MaterialStructArrayUniform","textures","$12pjC","RenderTarget2DArray","texture","cameraWorldMatrix","invProjectionMatrix","environmentBlur","environmentIntensity","environmentMap","seed","gradientTop","gradientBottom","bgGradientTop","bgGradientBottom","floorHeight","floorColor","shaderStructs","shaderIntersectFunction","$5Wq6T","shaderMaterialStructs","pathTracingHelpers","defineProperty","setDefine","needsUpdate","$465cbee6efe1dae1$var$isTypedArray","arr","buffer","ArrayBuffer","$465cbee6efe1dae1$export$c80603c061964928","ignoreKeys","shareTextures","areEqual","objectA","objectB","keySet","traverseSet","aIsElement","Element","bIsElement","Image","src","aIsImageBitmap","ImageBitmap","bIsImageBitmap","equals","aIsTypedArray","bIsTypedArray","clear","hasOwnProperty","Function","key1","keys","from","values","delete","process","object","replaced","processMaterial","foundMaterial","otherMaterial","isTexture","image","foundTexture","retained","$5aae44c9b1864d53$var$Stats","mode","container","document","createElement","addPanel","panel","appendChild","dom","showPanel","id","style","display","cssText","addEventListener","event","preventDefault","beginTime","performance","Date","now","prevTime","frames","fpsPanel","Panel","msPanel","self","memory","memPanel","REVISION","begin","end","time","update","usedJSHeapSize","jsHeapSizeLimit","domElement","setMode","fg","bg","round","PR","window","devicePixelRatio","WIDTH","HEIGHT","TEXT_X","TEXT_Y","GRAPH_X","GRAPH_Y","GRAPH_WIDTH","GRAPH_HEIGHT","canvas","width","height","context","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","maxValue","drawImage","$5aae44c9b1864d53$export$2e2bcd8739ae039","$766d62c886704c84$var$creditEl","getElementById","$766d62c886704c84$var$loadingEl","$766d62c886704c84$var$samplesEl","$766d62c886704c84$var$viewer","_container","scene","Scene","camera","PerspectiveCamera","innerWidth","innerHeight","renderer","WebGLRenderer","antialias","fsQuad","$RPVlj","FullScreenQuad","MeshBasicMaterial","ptRenderer","$hWds8","PathTracingRenderer","ptModel","ptMaterials","ptTextures","bvhGenerator","$a8VBx","GenerateMeshBVHWorker","onRender","enablePathTracing","pausePathTracing","samplesPerFrame","_scale","_nextObject","_needsSizeUpdate","_newSize","Vector2","_resizeObserver","ResizeObserver","entries","contentRect","overflow","outputEncoding","sRGBEncoding","observe","_updateSize","dpr","setPixelRatio","aspectRatio","setSize","target","aspect","updateProjectionMatrix","setScale","setModel","bvhOptions","running","updateMatrixWorld","meshes","$jM3IF","mergeMeshes","attributes","generate","strategy","SAH","maxLeafTris","remove","tex","dispose","mat","mesh","updateFrom","normal","tangent","uv","materialIndex","setTextures","reset","setEnvironment","envMap","environment","init","controls","$5Rd1x","OrbitControls","delaySamples","tiles","setAnimationLoop","samples","render","autoClear","body","$766d62c886704c84$var$envMaps","Overpass","$766d62c886704c84$var$models","MODEL_LIST","credit","rotation","PI","removeEmission","Statue","$766d62c886704c84$var$params","acesToneMapping","resolutionScale","tilesX","tilesY","backgroundType","enable","bounces","floorEnabled","$766d62c886704c84$var$gui","$766d62c886704c84$var$updateEnvMap","$891vQ","RGBELoader","pmremGenerator","PMREMGenerator","compileCubemapShader","fromEquirectangular","mapping","EquirectangularReflectionMapping","background","$766d62c886704c84$var$updateModel","destroy","LoadingManager","modelInfo","visibility","innerText","onFinish","emissiveMap","emissiveIntensity","side","DoubleSide","hsl","getHSL","setHSL","h","s","box","Box3","setFromObject","sphere","Sphere","getBoundingSphere","setScalar","radius","percent","floor","innerHTML","$jiuw3","GUI","onChange","resolutionFolder","addFolder","open","environmentFolder","backgroundFolder","Number","addColor","floorFolder","pathTracingFolder","toneMapping","ACESFilmicToneMapping","NoToneMapping","$766d62c886704c84$var$buildGui","$7lx9d","GLTFLoader","setMeshoptDecoder","$kp7Te","MeshoptDecoder","gltf","progress","total","loaded","preloadMaterials","static","extractGroup","newGeometry","originalPositions","getAttribute","array","originalNormals","numVertsGroup","count","start","vertStart","vertEnd","subarray","addGeometry","geometries","geoms","uuid","permuteAttribute","attribute","elemSize","verts","numVerts","meshGeometries","linesGeometries","condLinesGeometries","normalMatrix","Matrix3","matrixWorld","control0","control1","getNormalMatrix","applyNormalMatrix","groupIndex","groups","mergedObject","meshMaterialsIds","meshGeometry","mergedGeometry","$7ePFa","mergeBufferGeometries","linesMaterialsIds","lineGeometry","condLinesMaterialsIds","condLineGeometry","condLines","mergeObject","visible","$766d62c886704c84$var$stats","physicallyCorrectLights"],"version":3,"file":"lambert.adc0673f.js.map"}